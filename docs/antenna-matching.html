<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Antenna Impedance Matching - Smith Chart</title>
  <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script src="https://unpkg.com/mathjs@12/lib/browser/math.js"></script>
  <script src="https://unpkg.com/fmin@0.0.2/build/fmin.min.js"></script>
  <style>
    body { margin: 0; }

    /* Layout */
    .app {
      min-height: 100vh;
      background: #0a0a0a;
      color: #e0e0e0;
      font-family: "JetBrains Mono", "SF Mono", Monaco, Consolas, monospace;
      padding: 24px;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 20px;
      position: relative;
      overflow: hidden;
    }

    .experimental-banner {
      position: fixed;
      top: 44px;
      right: -60px;
      width: 260px;
      background: #e03131;
      color: #fff;
      font-size: 14px;
      font-weight: 700;
      letter-spacing: 2px;
      text-transform: uppercase;
      padding: 8px 0;
      text-align: center;
      transform: rotate(45deg);
      z-index: 100;
      pointer-events: none;
      box-shadow: 0 2px 8px rgba(0,0,0,0.4);
    }

    .main-content {
      display: flex;
      gap: 32px;
      flex-wrap: wrap;
      justify-content: center;
    }

    /* Buttons - Base */
    .btn {
      border: none;
      border-radius: 6px;
      cursor: pointer;
      font-family: inherit;
      font-weight: 600;
      transition: all 0.2s;
    }

    /* Mode Toggle */
    .mode-toggle {
      display: flex;
      gap: 8px;
      background: #1a1a1a;
      padding: 6px;
      border-radius: 8px;
    }

    .mode-btn {
      padding: 10px 20px;
      background: transparent;
      color: #888;
      font-size: 13px;
    }

    .mode-btn.active-gamma {
      background: #da77f2;
      color: #000;
    }

    .mode-btn.active-hairpin {
      background: #00ff88;
      color: #000;
    }

    .mode-btn.active-ocfd {
      background: #ffd43b;
      color: #000;
    }

    /* Title */
    .title {
      font-size: 18px;
      font-weight: 500;
      letter-spacing: 0.05em;
      color: #fff;
      margin: 0;
      text-transform: uppercase;
    }

    /* Presets */
    .presets {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
      justify-content: center;
    }

    .preset-btn {
      padding: 8px 14px;
      background: #1a1a1a;
      color: #888;
      border: 1px solid #333;
      font-size: 11px;
      font-weight: 400;
    }

    .preset-btn.active {
      background: #333;
      color: #fff;
    }

    .auto-tune-btn {
      padding: 8px 20px;
      color: #000;
      font-size: 11px;
    }

    .auto-tune-btn.gamma { background: #da77f2; }
    .auto-tune-btn.hairpin { background: #00ff88; }
    .auto-tune-btn.ocfd { background: #ffd43b; }

    /* Smith Chart */
    .smith-chart {
      background: #111;
      border-radius: 8px;
      flex-shrink: 0;
      aspect-ratio: 1;
    }

    /* Controls */
    .controls {
      display: flex;
      flex-direction: column;
      gap: 12px;
      min-width: 300px;
    }

    .control-panel {
      background: #1a1a1a;
      padding: 14px;
      border-radius: 8px;
      border: 1px solid #333;
    }

    .control-header {
      font-size: 11px;
      margin-bottom: 10px;
      font-weight: 600;
    }

    .control-label {
      display: block;
      margin-bottom: 8px;
    }

    .control-label:last-of-type {
      margin-bottom: 0;
    }

    .control-text {
      font-size: 12px;
      color: #888;
    }

    .control-slider {
      width: 100%;
      margin-top: 4px;
    }

    .control-result {
      font-size: 11px;
      color: #aaa;
      margin-top: 6px;
    }

    .control-hint {
      font-size: 10px;
      color: #666;
      margin-top: 2px;
    }

    .impedance-display {
      margin-top: 8px;
      font-size: 13px;
      color: #fff;
      font-weight: 500;
    }

    /* Result Panel */
    .result-panel {
      padding: 14px;
      border-radius: 8px;
      border-width: 2px;
      border-style: solid;
    }

    .result-panel.good { background: #0a1a0a; border-color: #00ff88; }
    .result-panel.normal { background: #1a1a1a; }

    .result-z {
      font-size: 18px;
      color: #fff;
      margin-bottom: 6px;
      font-weight: 600;
    }

    .result-swr {
      font-size: 16px;
      font-weight: 600;
    }

    .swr-excellent { color: #00ff88; }
    .swr-good { color: #4ade80; }
    .swr-ok { color: #ffd43b; }
    .swr-poor { color: #ff6b6b; }

    .swr-table {
      display: flex;
      flex-direction: column;
      gap: 4px;
      margin-top: 6px;
    }

    .swr-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-size: 13px;
    }

    .swr-row-label {
      color: #888;
      font-size: 12px;
    }

    .swr-row-value {
      font-weight: 600;
    }

    .feedline-selector {
      display: flex;
      gap: 6px;
    }

    .swr-row-best {
      background: rgba(255, 255, 255, 0.05);
      padding: 2px 6px;
      border-radius: 4px;
    }

    /* Physical Diagram */
    .diagram-container {
      background: #111;
      padding: 20px;
      border-radius: 8px;
      max-width: 650px;
      width: 100%;
    }

    .diagram-title {
      color: #888;
      font-size: 11px;
      margin-bottom: 12px;
      text-align: center;
      font-weight: 600;
    }

    .diagram-svg {
      display: block;
      width: 100%;
    }

    /* Info */
    .info {
      max-width: 680px;
      font-size: 12px;
      color: #666;
      line-height: 1.6;
      text-align: center;
    }

    .info strong {
      color: #aaa;
    }

    /* Footer */
    .footer {
      font-size: 11px;
      color: #555;
      text-align: center;
      margin-top: 12px;
    }

    .footer a {
      color: #888;
    }

    /* Physical params */
    .physical-params {
      display: flex;
      gap: 16px;
      font-size: 11px;
      color: #666;
    }

    .physical-params label {
      display: flex;
      align-items: center;
      gap: 4px;
    }

    .physical-params input {
      width: 60px;
      padding: 4px 6px;
      background: #1a1a1a;
      border: 1px solid #333;
      border-radius: 4px;
      color: #aaa;
      font-family: inherit;
      font-size: 11px;
    }

    .physical-params input:focus {
      outline: none;
      border-color: #555;
    }

    .btn:focus-visible {
      outline: 2px solid #4dabf7;
      outline-offset: 2px;
    }

    input:focus-visible {
      outline: 2px solid #4dabf7;
      outline-offset: 1px;
    }

    .physical-hint {
      font-size: 10px;
      color: #888;
      margin-top: 4px;
    }

    /* Mobile responsive */
    @media (max-width: 800px) {
      .app {
        padding: 16px;
        gap: 16px;
      }

      .main-content {
        flex-direction: column;
        align-items: center;
      }

      .smith-chart {
        width: 100%;
        max-width: 400px;
        height: auto;
        aspect-ratio: 1;
      }

      .controls {
        min-width: unset;
        width: 100%;
        max-width: 400px;
      }

      .physical-params {
        flex-wrap: wrap;
        justify-content: center;
      }

      .mode-toggle {
        flex-wrap: wrap;
        justify-content: center;
      }

      .presets {
        justify-content: center;
      }

      .diagram-container {
        max-width: 100%;
      }
    }

    /* Tooltips */
    [data-tooltip] {
      position: relative;
    }

    [data-tooltip]:hover::after {
      content: attr(data-tooltip);
      position: absolute;
      bottom: 100%;
      left: 50%;
      transform: translateX(-50%);
      background: #333;
      color: #fff;
      padding: 6px 10px;
      border-radius: 4px;
      font-size: 11px;
      white-space: nowrap;
      z-index: 100;
      margin-bottom: 4px;
    }

    /* Print styles */
    @media print {
      .app {
        background: white;
        color: black;
        padding: 0;
      }

      .mode-toggle,
      .presets,
      .physical-params,
      input[type="range"],
      .footer a {
        display: none;
      }

      .control-panel,
      .result-panel {
        background: white;
        border: 1px solid #999;
        break-inside: avoid;
      }

      .control-header,
      .control-text,
      .control-result,
      .control-hint,
      .physical-hint,
      .diagram-title,
      .info,
      .info strong,
      .title {
        color: black;
      }

      .smith-chart,
      .diagram-container {
        background: white;
      }

      .footer {
        color: #666;
      }
    }
  </style>
</head>
<body>
  <div id="root"></div>
  <script type="text/babel">
    const { useState, useMemo, useCallback, useEffect, useRef } = React;
    const { complex, add, subtract, multiply, divide } = math;

    // ============================================================
    // JSDoc Type Definitions
    // ============================================================

    /**
     * @typedef {Object} Impedance
     * @property {number} r - Resistance in ohms
     * @property {number} x - Reactance in ohms (positive = inductive, negative = capacitive)
     */

    /**
     * @typedef {Object} ReflectionCoefficient
     * @property {number} re - Real part of gamma
     * @property {number} im - Imaginary part of gamma
     */

    /**
     * @typedef {Object} ScreenPoint
     * @property {number} x - X coordinate on screen
     * @property {number} y - Y coordinate on screen
     */

    /**
     * @typedef {Object} GammaMatchResult
     * @property {ScreenPoint} origPt - Original impedance point
     * @property {ScreenPoint} afterTapPt - Point after tap ratio transformation
     * @property {ScreenPoint} afterShuntPt - Point after shunt inductance
     * @property {ScreenPoint} finalPt - Final matched impedance point
     * @property {Impedance} afterTap - Impedance after tap ratio
     * @property {Impedance} afterShunt - Impedance after shunt inductance
     * @property {Impedance} finalZ - Final matched impedance
     * @property {ScreenPoint[]} tapPath - Path for tap ratio transformation
     * @property {ScreenPoint[]} shuntPath - Path for shunt inductance
     * @property {ScreenPoint[]} seriesPath - Path for series capacitor
     * @property {number} swr - Standing wave ratio
     */

    /**
     * @typedef {Object} HairpinMatchResult
     * @property {ScreenPoint} origPt - Original impedance point
     * @property {ScreenPoint} shortenedPt - Point after shortening
     * @property {ScreenPoint} finalPt - Final matched impedance point
     * @property {Impedance} afterShorten - Impedance after shortening
     * @property {Impedance} finalZ - Final matched impedance
     * @property {ScreenPoint[]} shortenPath - Path for shortening transformation
     * @property {ScreenPoint[]} hpPath - Path for hairpin inductance
     * @property {number} swr - Standing wave ratio
     */

    /**
     * @typedef {Object} SmithChartGeometry
     * @property {function(number, number): ScreenPoint} zToScreen - Convert impedance to screen coordinates
     * @property {Array<{r: number, cx: number, radius: number}>} rCircles - Constant resistance circles
     * @property {Array<{x: number, cx: number, cy: number, radius: number}>} xArcs - Constant reactance arcs
     * @property {function(number, number, number, number): ScreenPoint[]} createXArc - Create points for reactance arc
     */

    /**
     * @typedef {Object} Preset
     * @property {string} label - Display label
     * @property {number} r - Resistance value
     * @property {number} x - Reactance value
     */

    // ============================================================
    // Constants
    // ============================================================

    /** @type {number} Characteristic impedance */
    const Z0 = 50;

    /** @type {number} Smith chart size in pixels */
    const SIZE = 520;

    /** @type {number} Smith chart center X */
    const CX = SIZE / 2;

    /** @type {number} Smith chart center Y */
    const CY = SIZE / 2;

    /** @type {number} Smith chart radius */
    const RADIUS = SIZE / 2 - 45;

    /** @type {Object} Color palette */
    const COLORS = Object.freeze({
      orig: '#ff6b6b',
      step1: '#ffa94d',
      step2: '#da77f2',
      step3: '#66d9e8',
      final: '#4dabf7',
      hairpin: '#00ff88',
      ocfd: '#ffd43b',
      coax: '#4dabf7',
      // Grid colors (dark to light)
      grid: '#444',
      gridOuter: '#555',
      gridCenter: '#666',
      label: '#888',
      element: '#666',
      wire: '#888'
    });

    /** @type {number[]} Feedline impedances for OCFD SWR calculations */
    const FEEDLINE_IMPEDANCES = Object.freeze([50, 75, 100, 150, 300, 450]);

    /** @type {Preset[]} Gamma match antenna presets */
    const GAMMA_PRESETS = Object.freeze([
      { label: 'Resonant Dipole (67Ω)', r: 67, x: 0 },
      { label: 'Yagi (25Ω)', r: 25, x: 0 },
      { label: 'Low-Z Yagi (18−j10Ω)', r: 18, x: -10 },
    ]);

    /** @type {Preset[]} Hairpin match antenna presets */
    const HAIRPIN_PRESETS = Object.freeze([
      { label: 'Yagi (25Ω)', r: 25, x: 0 },
      { label: 'Low-Z Yagi (18−j10Ω)', r: 18, x: -10 },
      { label: 'Resonant Dipole (67Ω)', r: 67, x: 0 },
    ]);

    /** @type {Preset[]} OCFD center impedance presets (includes feedOffset) */
    const OCFD_PRESETS = Object.freeze([
      { label: 'Free-Space λ/2 (73+j43Ω)', r: 73, x: 43, groundType: 'free' },
      { label: 'Resonant, λ/2 AGL, Average Ground', r: 67, x: 0, groundType: 'average',
        heightFraction: 0.5 },
      { label: 'Resonant, λ/4 AGL, Average Ground', r: 77, x: 17, groundType: 'average',
        heightFraction: 0.25 },
    ]);

    /** @type {number[]} Normalized resistance values for Smith chart circles */
    const R_VALUES = Object.freeze([0, 0.2, 0.5, 1, 2, 5]);

    /** @type {number[]} Normalized reactance values for Smith chart arcs */
    const X_VALUES = Object.freeze([0.2, 0.5, 1, 2, 5]);

    /** @type {number} Speed of light in m/s */
    const C_SPEED = 299792458;

    /** @type {number} Number of points for path generation */
    const PATH_STEPS = 50;

    /** Max resistance for path clipping */
    const PATH_R_MAX = 1000;

    /** Threshold below which shunt reactance is treated as zero (open circuit) */
    const SHUNT_X_MIN = 0.1;

    /** Maximum displayable SWR (returned when reflection coefficient >= 1) */
    const SWR_MAX = 99;

    /** @type {Object} SWR thresholds for color coding */
    const SWR_THRESHOLDS = Object.freeze({
      excellent: 1.2,
      good: 1.5,
      ok: 2.0
    });

    /** @type {Object} Match mode constants */
    const MODES = Object.freeze({
      GAMMA: 'gamma',
      HAIRPIN: 'hairpin',
      OCFD: 'ocfd'
    });

    /** @type {Object} URL parameter keys */
    const URL_KEYS = Object.freeze({
      mode: 'mode',
      antR: 'r',
      antX: 'x',
      tapRatio: 'tap',
      gammaRodX: 'rod',
      seriesCapX: 'cap',
      shortening: 'short',
      hairpinX: 'hp',
      freqMHz: 'freq',
      elementDiamMm: 'diam',
      ocfdR: 'ocr',
      ocfdX: 'ocx',
      feedOffset: 'off',
      feedlineZ0: 'z0',
      heightM: 'ht',
      groundType: 'gnd'
    });

    // ============================================================
    // Impedance Math Utilities
    // ============================================================

    /**
     * Create complex number from resistance and reactance.
     * Intentionally short name — used heavily in impedance math expressions
     * where verbosity would hurt readability.
     * @param {number} r - Resistance
     * @param {number} x - Reactance
     * @returns {Object} Complex number
     */
    const C = (r, x) => complex(r, x);

    /**
     * Create impedance object with formatting methods
     * @param {number} r - Resistance
     * @param {number} x - Reactance
     * @returns {Impedance}
     */
    const Z = (r, x) => ({
      r, x,
      format() {
        const fmtNum = (v) => !isFinite(v) || Math.abs(v) >= 1e9 ? '∞' : v.toFixed(1);
        return `${fmtNum(this.r)} ${this.x >= 0 ? '+' : '−'} j${fmtNum(Math.abs(this.x))}`;
      },
      formatLabel() {
        const fmtNum = (v) => !isFinite(v) || Math.abs(v) >= 1e9 ? '∞' : Math.round(v);
        return `${fmtNum(this.r)}${this.x >= 0 ? '+' : ''}j${fmtNum(this.x)}Ω`;
      }
    });

    /**
     * Convert complex number to impedance object
     * @param {Object} z - Complex number
     * @returns {Impedance}
     */
    const toRX = (z) => Z(z.re, z.im);

    /**
     * Convert impedance to reflection coefficient: Γ = (z - 1) / (z + 1)
     * @param {Impedance} z - Impedance
     * @returns {ReflectionCoefficient}
     */
    const zToGamma = (z) => {
      const zNorm = C(z.r / Z0, z.x / Z0);
      const gamma = divide(subtract(zNorm, 1), add(zNorm, 1));
      return { re: gamma.re, im: gamma.im };
    };

    /**
     * Apply tap ratio transformation: Z_new = Z × n²
     * @param {Impedance} z - Impedance
     * @param {number} ratio - Tap ratio (n)
     * @returns {Impedance}
     */
    const applyTapRatio = (z, ratio) => {
      const n2 = ratio * ratio;
      return Z(z.r * n2, z.x * n2);
    };

    /**
     * Add shunt reactance: Y_total = Y + Y_shunt, Z = 1/Y_total
     * @param {Impedance} z - Impedance
     * @param {number} xShunt - Shunt reactance value
     * @returns {Impedance}
     */
    const addShuntReactance = (z, xShunt) => {
      if (Math.abs(xShunt) < SHUNT_X_MIN) return z;
      const zc = C(z.r, z.x);
      const y = divide(1, zc);
      const yShunt = C(0, -1 / xShunt);
      const yTotal = add(y, yShunt);
      const zNew = divide(1, yTotal);
      return toRX(zNew);
    };

    /**
     * Add series reactance: Z_new = Z + jX_series
     * @param {Impedance} z - Impedance
     * @param {number} xSeries - Series reactance to add
     * @returns {Impedance}
     */
    const addSeriesReactance = (z, xSeries) => Z(z.r, z.x + xSeries);

    /**
     * Calculate SWR from impedance (relative to Z0=50Ω)
     * @param {Impedance} z - Impedance
     * @returns {number} SWR value
     */
    const calcSWR = (z) => {
      const gamma = zToGamma(z);
      const gammaMag = Math.sqrt(gamma.re ** 2 + gamma.im ** 2);
      if (gammaMag >= 1) return SWR_MAX;
      return (1 + gammaMag) / (1 - gammaMag);
    };

    /**
     * Calculate SWR for arbitrary feedline impedance Z₀
     * Γ = (Z_feed − Z₀) / (Z_feed + Z₀), SWR = (1+|Γ|) / (1−|Γ|)
     * @param {Impedance} z - Feed impedance
     * @param {number} z0 - Feedline characteristic impedance
     * @returns {number} SWR value
     */
    const calcSWRForZ0 = (z, z0) => {
      const zc = C(z.r, z.x);
      const gamma = divide(subtract(zc, z0), add(zc, z0));
      const gammaMag = Math.sqrt(gamma.re ** 2 + gamma.im ** 2);
      if (gammaMag >= 1) return SWR_MAX;
      return (1 + gammaMag) / (1 - gammaMag);
    };

    // ============================================================
    // Special Functions (Sine/Cosine Integrals)
    // ============================================================

    /** Euler-Mascheroni constant */
    const EULER_GAMMA = 0.5772156649015329;

    /**
     * Auxiliary functions f(x), g(x) for asymptotic expansion of Si/Ci.
     * Si(x) = π/2 - f(x)cos(x) - g(x)sin(x)
     * Ci(x) = f(x)sin(x) - g(x)cos(x)
     * @param {number} x - Must be > 0
     * @returns {{f: number, g: number}}
     */
    const siCiAsymptotic = (x) => {
      // f(x) ~ (1/x) Σ (-1)^n (2n)! / x^(2n)
      // g(x) ~ (1/x²) Σ (-1)^n (2n+1)! / x^(2n)
      // Truncate at smallest term (asymptotic series diverge)
      let fSum = 0, fTerm = 1;
      let gSum = 0, gTerm = 1;
      const x2 = x * x;
      for (let n = 0; n < 20; n++) {
        fSum += fTerm;
        gSum += gTerm;
        const nextF = -fTerm * (2 * n + 1) * (2 * n + 2) / x2;
        if (Math.abs(nextF) > Math.abs(fTerm)) break;
        fTerm = nextF;
        gTerm = -gTerm * (2 * n + 2) * (2 * n + 3) / x2;
      }
      return { f: fSum / x, g: gSum / x2 };
    };

    /**
     * Sine integral: Si(x) = ∫₀ˣ sin(t)/t dt
     * Abramowitz & Stegun, Eq. 5.2.1.
     * Uses power series for |x| < 20, asymptotic expansion for |x| >= 20.
     * @param {number} x
     * @returns {number}
     */
    const Si = (x) => {
      const sign = x < 0 ? -1 : 1;
      const ax = Math.abs(x);
      if (ax < 20) {
        let sum = 0, term = ax;
        for (let n = 0; n < 40; n++) {
          if (n > 0) term *= -ax * ax / (2 * n * (2 * n + 1));
          sum += term / (2 * n + 1);
        }
        return sign * sum;
      }
      const { f, g } = siCiAsymptotic(ax);
      return sign * (Math.PI / 2 - f * Math.cos(ax) - g * Math.sin(ax));
    };

    /**
     * Cosine integral: Ci(x) = γ + ln(x) + ∫₀ˣ (cos(t)-1)/t dt
     * Abramowitz & Stegun, Eq. 5.2.2.
     * Uses power series for x < 20, asymptotic expansion for x >= 20.
     * @param {number} x - Must be > 0
     * @returns {number}
     */
    const Ci = (x) => {
      if (x < 20) {
        let sum = EULER_GAMMA + Math.log(x), term = 1;
        for (let n = 1; n <= 40; n++) {
          term *= -x * x / ((2 * n - 1) * (2 * n));
          sum += term / (2 * n);
        }
        return sum;
      }
      const { f, g } = siCiAsymptotic(x);
      return f * Math.sin(x) - g * Math.cos(x);
    };

    // ============================================================
    // Dipole Impedance (Induced EMF Method)
    // ============================================================

    /**
     * Dipole feedpoint impedance via the Induced EMF method.
     *
     * R_in: Balanis, "Antenna Theory" 4e, Eq. (8-60a)
     * X_in: Balanis, Eq. (8-60b); wire radius enters via Ci(2ka²/l) term
     *
     * See also: Stearns, K6OIK, "Antenna Impedance Models,"
     * ARRL Pacificon 2004, slide 15; "Dipole Basics," Pacificon 2019,
     * slides 18, 43-47 (shortening factor K).
     *
     * @param {number} freqMHz - Frequency in MHz
     * @param {number} lengthM - Total dipole length in meters
     * @param {number} wireRadiusM - Wire radius in meters
     * @returns {Impedance} Feedpoint impedance
     */
    const calcDipoleIEMF = (freqMHz, lengthM, wireRadiusM) => {
      const eta = 120 * Math.PI;
      const lambda = C_SPEED / (freqMHz * 1e6);
      const k = 2 * Math.PI / lambda;
      const l = lengthM;
      const a = wireRadiusM;
      const kl = k * l;
      const sinHalf = Math.sin(kl / 2);
      if (Math.abs(sinHalf) < 1e-12) return Z(Infinity, 0);
      const denom = 2 * Math.PI * sinHalf * sinHalf;

      const sinKl = Math.sin(kl);
      const cosKl = Math.cos(kl);

      const Rin = (eta / denom) * (
        EULER_GAMMA + Math.log(kl) - Ci(kl)
        + 0.5 * sinKl * (Si(2 * kl) - 2 * Si(kl))
        + 0.5 * cosKl * (EULER_GAMMA + Math.log(kl / 2) + Ci(2 * kl) - 2 * Ci(kl))
      );

      const Xin = (eta / denom) * (
        Si(kl)
        + 0.5 * cosKl * (2 * Si(kl) - Si(2 * kl))
        - 0.5 * sinKl * (2 * Ci(kl) - Ci(2 * kl) - Ci(2 * k * a * a / l))
      );

      return Z(Rin, Xin);
    };

    /**
     * Find the resonant dipole length (where X_in = 0) via bisection.
     * The resonant length is slightly shorter than λ/2 due to finite
     * wire diameter. The shortening factor K = L_resonant / (λ/2)
     * depends on Ω' = 2·ln(2L/a), the antenna thickness parameter.
     *
     * Stearns, K6OIK, "Dipole Basics," Pacificon 2019, slides 43-47.
     *
     * @param {number} freqMHz - Frequency in MHz
     * @param {number} wireDiamMm - Wire diameter in mm
     * @returns {{ z: Impedance, lengthM: number, K: number }}
     */
    const calcDipoleResonant = (freqMHz, wireDiamMm) => {
      const lambda = C_SPEED / (freqMHz * 1e6);
      const wireRadiusM = (wireDiamMm / 1000) / 2;

      // Bisection: X_in > 0 at λ/2, decreases as dipole shortens
      let lo = 0.42 * lambda;
      let hi = 0.50 * lambda;
      const xLo = calcDipoleIEMF(freqMHz, lo, wireRadiusM).x;
      const xHi = calcDipoleIEMF(freqMHz, hi, wireRadiusM).x;
      if (xLo * xHi > 0 || !isFinite(xLo) || !isFinite(xHi)) {
        // No sign change or degenerate input — fall back to λ/2
        const lengthM = lambda / 2;
        return { z: calcDipoleIEMF(freqMHz, lengthM, wireRadiusM), lengthM, K: 1 };
      }
      for (let i = 0; i < 60; i++) {
        const mid = (lo + hi) / 2;
        if (calcDipoleIEMF(freqMHz, mid, wireRadiusM).x > 0) hi = mid;
        else lo = mid;
      }
      const lengthM = (lo + hi) / 2;
      const z = calcDipoleIEMF(freqMHz, lengthM, wireRadiusM);
      const K = lengthM / (lambda / 2);
      return { z, lengthM, K };
    };

    // ============================================================
    // Ground Reflection
    // ============================================================

    /** @type {Object} Ground type parameters (ε_r, σ in S/m) */
    const GROUND_TYPES = Object.freeze({
      free:    { label: 'Free space', er: null, sigma: null },
      perfect: { label: 'Perfect', er: Infinity, sigma: Infinity },
      sea:     { label: 'Sea water', er: 80, sigma: 5.0 },
      wet:     { label: 'Wet', er: 30, sigma: 0.01 },
      average: { label: 'Average', er: 13, sigma: 0.005 },
      dry:     { label: 'Dry', er: 5, sigma: 0.001 },
      city:    { label: 'City', er: 3, sigma: 0.001 },
    });

    /**
     * Fresnel reflection coefficient for horizontal polarization at broadside (ψ=π/2).
     * Γ_h = (1 - √ε_c) / (1 + √ε_c) where ε_c = ε_r - jσ/(ωε₀)
     *
     * Balanis, "Antenna Theory" 4e, Eq. (4-128) for horizontal polarization.
     * Ground parameters from ITU-R P.527-6, Table 1.
     * See also: Stearns, K6OIK, "Dipole Basics," Pacificon 2019, slide 80.
     *
     * @param {number} freqMHz - Frequency in MHz
     * @param {number} er - Relative permittivity
     * @param {number} sigma - Conductivity in S/m
     * @returns {{re: number, im: number}} Complex reflection coefficient
     */
    const calcGroundReflection = (freqMHz, er, sigma) => {
      if (!isFinite(er)) return { re: -1, im: 0 };
      const eps0 = 8.854187817e-12;
      const omega = 2 * Math.PI * freqMHz * 1e6;
      // ε_c = ε_r - jσ/(ωε₀) as a complex number
      const epsC = complex(er, -sigma / (omega * eps0));
      const sqrtEps = math.sqrt(epsC);
      // Γ_h = (1 - √ε_c) / (1 + √ε_c)
      const num = math.subtract(1, sqrtEps);
      const den = math.add(1, sqrtEps);
      const gamma = math.divide(num, den);
      return { re: gamma.re, im: gamma.im };
    };

    // ============================================================
    // Dipole Over Ground
    // ============================================================

    /**
     * Resonant dipole impedance over ground.
     * Uses the free-space resonant length (X_in = 0) rather than λ/2
     * when wire diameter is provided; otherwise falls back to the
     * standard half-wave approximation (73.1 + j42.5 Ω).
     *
     * Z_input = Z_self + Γ_ground · Z_mutual(2h)
     *
     * Mutual impedance: Balanis, "Antenna Theory" 4e, Eqs. (8-68a), (8-68b).
     * Image theory: Balanis, Section 4.7.2.
     * See also: Stearns, K6OIK, "Dipole Basics," Pacificon 2019, slide 80
     * (impedance vs height for various ground conductivities).
     *
     * @param {number} freqMHz - Frequency in MHz
     * @param {number} heightM - Height above ground in meters
     * @param {number} [wireDiamMm] - Wire diameter in mm (computes resonant
     *   length via IEMF if provided; otherwise uses half-wave approximation)
     * @param {string} [groundType='perfect'] - Key into GROUND_TYPES
     * @returns {(Impedance & { lengthM: number, K: number })|null}
     */
    const calcDipoleOverGround = (freqMHz, heightM, wireDiamMm, groundType) => {
      const freq = parseFloat(freqMHz);
      if (!freq || freq <= 0) return null;

      const lambda = C_SPEED / (freq * 1e6);
      const diam = parseFloat(wireDiamMm);
      let zSelf, lengthM, K;
      if (diam > 0) {
        const res = calcDipoleResonant(freq, diam);
        zSelf = res.z;
        lengthM = res.lengthM;
        K = res.K;
      } else {
        // No wire diameter — use standard half-wave values (not resonant)
        zSelf = Z(73.1, 42.5);
        lengthM = lambda / 2;
        K = 1;
      }

      // Free space: no ground image, just Z_self
      const gnd = GROUND_TYPES[groundType];
      if (gnd && gnd.er === null) return { ...zSelf, lengthM, K };

      const h = parseFloat(heightM);
      if (!h || h <= 0) return null;

      const beta = 2 * Math.PI / lambda;
      const d = 2 * h;
      const L = lengthM;
      const dL = Math.sqrt(d * d + L * L);

      const u0 = beta * d;
      const u1 = beta * (dL + L);
      const u2 = beta * (dL - L);

      const R12 = 30 * (2 * Ci(u0) - Ci(u1) - Ci(u2));
      const X12 = -30 * (2 * Si(u0) - Si(u1) - Si(u2));

      // Ground reflection: Fresnel for lossy ground, PEC (Γ = -1) by default
      const gammaG = gnd
        ? calcGroundReflection(freq, gnd.er, gnd.sigma)
        : { re: -1, im: 0 };

      // Z_input = Z_self + Γ · Z_mutual
      // For PEC (Γ = -1): Z_self - Z_mutual (matches original behavior)
      const rMut = gammaG.re * R12 - gammaG.im * X12;
      const xMut = gammaG.re * X12 + gammaG.im * R12;

      return { ...Z(zSelf.r + rMut, zSelf.x + xMut), lengthM, K };
    };

    // ============================================================
    // SVG Path Utilities
    // ============================================================

    /**
     * Convert array of points to SVG path string
     * @param {ScreenPoint[]} points
     * @returns {string}
     */
    const pointsToPath = (points) =>
      points.map((p, i) => `${i === 0 ? 'M' : 'L'} ${p.x} ${p.y}`).join(' ');

    /**
     * Calculate shunt arc path and arrow angle along constant-G circle
     * @param {Impedance} z - Starting impedance
     * @param {number} shuntX - Shunt reactance to add
     * @param {function} zToScreen - Impedance to screen coordinate converter
     * @returns {{startPt: ScreenPoint, endPt: ScreenPoint, endZ: Impedance, arcPath: string, arrowAngle: number}}
     */
    const calcShuntArc = (z, shuntX, zToScreen) => {
      const startPt = zToScreen(z);
      const endZ = addShuntReactance(z, shuntX);
      const endPt = zToScreen(endZ);

      // Normalized conductance g = G * Z0 = Z0 * R / (R² + X²)
      const g = Z0 * z.r / (z.r ** 2 + z.x ** 2);

      // Constant-G circle: center at (-g/(g+1), 0) in Gamma, radius 1/(g+1)
      const circleRadius = RADIUS / (g + 1);
      const circleCx = CX - (g / (g + 1)) * RADIUS;
      const circleCy = CY;

      // Vectors from circle center to start and end
      const v1x = startPt.x - circleCx, v1y = startPt.y - circleCy;
      const v2x = endPt.x - circleCx, v2y = endPt.y - circleCy;

      // Cross product determines sweep direction (positive = counter-clockwise)
      const cross = v1x * v2y - v1y * v2x;
      const sweepFlag = cross > 0 ? 1 : 0;

      // Determine large-arc-flag from angular span
      const ang1 = Math.atan2(v1y, v1x);
      const ang2 = Math.atan2(v2y, v2x);
      let angSpan = ang2 - ang1;
      if (sweepFlag) { if (angSpan < 0) angSpan += 2 * Math.PI; }
      else { if (angSpan > 0) angSpan -= 2 * Math.PI; }
      const largeArcFlag = Math.abs(angSpan) > Math.PI ? 1 : 0;

      const arcPath = `M ${startPt.x} ${startPt.y} A ${circleRadius} ${circleRadius} 0 ${largeArcFlag} ${sweepFlag} ${endPt.x} ${endPt.y}`;

      // Arrow angle: tangent to circle at endpoint
      // Tangent is perpendicular to radius; direction depends on sweep
      const radialAngle = Math.atan2(endPt.y - circleCy, endPt.x - circleCx);
      const arrowAngle = (radialAngle + (sweepFlag ? Math.PI / 2 : -Math.PI / 2)) * 180 / Math.PI;

      return { startPt, endPt, endZ, arcPath, arrowAngle };
    };

    // ============================================================
    // Custom Hooks
    // ============================================================

    /**
     * Hook for Smith chart geometry calculations
     * @returns {SmithChartGeometry}
     */
    const useSmithChart = () => {
      return useMemo(() => {
        /**
         * Convert reflection coefficient to screen coordinates
         * @param {ReflectionCoefficient} gamma
         * @returns {ScreenPoint}
         */
        const gammaToScreen = (gamma) => ({
          x: CX + gamma.re * RADIUS,
          y: CY - gamma.im * RADIUS
        });

        /**
         * Convert impedance to screen coordinates
         * @param {Impedance} z - Impedance
         * @returns {ScreenPoint}
         */
        const zToScreen = (z) => gammaToScreen(zToGamma(z));

        /** Constant resistance circles */
        const rCircles = R_VALUES.map(r => ({
          r,
          cx: CX + (r / (r + 1)) * RADIUS,
          radius: RADIUS / (r + 1)
        }));

        /** Constant reactance arcs */
        const xArcs = X_VALUES.flatMap(x => [x, -x]).map(x => ({
          x,
          cx: CX + RADIUS,
          cy: CY - RADIUS / x,
          radius: Math.abs(RADIUS / x)
        }));

        /**
         * Create points for a reactance arc clipped to the Smith chart
         *
         * Constant-x arcs are circles with center at Γ = (1, 1/x) and radius 1/|x|.
         * They intersect the unit circle at (1, 0) and ((x²-1)/(1+x²), 2x/(1+x²)).
         *
         * @param {number} x - Normalized reactance value
         * @param {number} arcCx - Arc center X (screen coords)
         * @param {number} arcCy - Arc center Y (screen coords)
         * @param {number} arcRadius - Arc radius (screen coords)
         * @returns {ScreenPoint[]}
         */
        const createXArc = (x, arcCx, arcCy, arcRadius) => {
          const x2 = x * x;
          const denom = 1 + x2;

          // Exact intersection points on unit circle (screen coords)
          const p1x = CX + RADIUS;  // Infinity point (1, 0)
          const p1y = CY;
          const p2x = CX + (x2 - 1) / denom * RADIUS;
          const p2y = CY - 2 * x / denom * RADIUS;

          // Angles from arc center to each intersection
          const angle1 = Math.atan2(p1y - arcCy, p1x - arcCx);
          const angle2 = Math.atan2(p2y - arcCy, p2x - arcCx);

          // Determine sweep direction: we want to stay inside unit circle
          // Test midpoint of both possible paths
          const midAngleDirect = (angle1 + angle2) / 2;
          const midAngleAlt = midAngleDirect + (midAngleDirect > 0 ? -Math.PI : Math.PI);

          const testMid = (angle) => {
            const gx = (arcCx + arcRadius * Math.cos(angle) - CX) / RADIUS;
            const gy = (CY - (arcCy + arcRadius * Math.sin(angle))) / RADIUS;
            return gx * gx + gy * gy;
          };

          // Choose path where midpoint is inside unit circle (|Γ|² < 1)
          const goLongWay = testMid(midAngleDirect) > testMid(midAngleAlt);
          const endAngle = goLongWay
            ? angle2 + (angle2 > angle1 ? -2 : 2) * Math.PI
            : angle2;

          // Generate arc points
          const points = [{ x: p1x, y: p1y }];  // Start exactly at infinity point
          for (let i = 1; i < PATH_STEPS; i++) {
            const angle = angle1 + (endAngle - angle1) * i / PATH_STEPS;
            points.push({
              x: arcCx + arcRadius * Math.cos(angle),
              y: arcCy + arcRadius * Math.sin(angle)
            });
          }
          points.push({ x: p2x, y: p2y });  // End exactly at intersection
          return points;
        };

        return { zToScreen, rCircles, xArcs, createXArc };
      }, []);
    };

    // ============================================================
    // Sub-Components
    // ============================================================

    /**
     * Arrow head component for path endpoints
     * @param {Object} props
     * @param {number} props.x - X position
     * @param {number} props.y - Y position
     * @param {number} props.angle - Rotation angle in degrees
     * @param {string} props.color - Fill color
     */
    const ArrowHead = ({ x, y, angle, color }) => (
      <polygon
        points="-7,-4 0,0 -7,4"
        fill={color}
        transform={`translate(${x}, ${y}) rotate(${angle})`}
      />
    );

    /**
     * Calculate arrow angle from path
     * @param {ScreenPoint[]} path - Array of points
     * @param {ScreenPoint} endPt - End point
     * @param {number} [offset=5] - Offset from end for angle calculation
     * @returns {number} Angle in degrees
     */
    const getArrowAngle = (path, endPt, offset = 5) => {
      if (path.length <= offset) return 0;
      const prev = path[path.length - offset];
      return Math.atan2(endPt.y - prev.y, endPt.x - prev.x) * 180 / Math.PI;
    };

    /**
     * Control panel wrapper component
     * @param {Object} props
     * @param {string} props.color - Border and header color
     * @param {string} props.title - Panel header text
     * @param {string} [props.tooltip] - Tooltip text
     * @param {React.ReactNode} props.children - Panel content
     */
    const ControlPanel = ({ color, title, tooltip, children }) => (
      <div className="control-panel" style={{ borderColor: color }} data-tooltip={tooltip}>
        <div className="control-header" style={{ color }}>{title}</div>
        {children}
      </div>
    );

    /**
     * Shared dipole calculator — computes resonant dipole impedance
     * (center feed) from wire geometry and ground conditions using the
     * induced EMF method with image theory. Displays shortening factor
     * K and Ω'. Available in all modes (gamma, hairpin, OCFD).
     */
    const DipoleCalculator = ({ state, set, setStr, onApplyZ, impedanceKeys }) => {
      const [open, setOpen] = useState(state.calcOpen > 0);
      const [infoOpen, setInfoOpen] = useState(false);
      const prevCalcOpen = useRef(state.calcOpen);
      useEffect(() => {
        if (state.calcOpen !== prevCalcOpen.current) {
          setOpen(state.calcOpen > 0);
          prevCalcOpen.current = state.calcOpen;
        }
      }, [state.calcOpen]);
      const freq = parseFloat(state.freqMHz);
      const diam = parseFloat(state.elementDiamMm);
      const hasFreqDiam = freq > 0 && diam > 0;
      const isFreeSpace = state.groundType === 'free';
      const h = parseFloat(state.heightM);
      const hasHeight = h > 0;
      const groundZ = hasFreqDiam && (isFreeSpace || hasHeight)
        ? calcDipoleOverGround(freq, h, diam, state.groundType)
        : null;
      const gndLabel = GROUND_TYPES[state.groundType]?.label || state.groundType;
      // Ω' = 2·ln(2L/a) where L = half-length, a = wire radius
      // Stearns, K6OIK, "Dipole Basics," Pacificon 2019, slide 18
      const omegaPrime = hasFreqDiam
        ? (() => {
            const a = (diam / 1000) / 2;
            const halfLen = groundZ ? groundZ.lengthM / 2 : (C_SPEED / (freq * 1e6)) / 4;
            return 2 * Math.log(2 * halfLen / a);
          })()
        : null;

      return (
        <div className="control-panel" style={{ borderColor: '#4ade80' }}
          data-tooltip="Compute center impedance from antenna geometry using the induced EMF method">
          <div style={{ display: 'flex', alignItems: 'center', gap: 8 }}>
            <div className="control-header" style={{ color: '#4ade80', cursor: 'pointer', userSelect: 'none', flex: 1 }}
              onClick={() => setOpen(o => !o)}
              onKeyDown={(e) => { if (e.key === 'Enter' || e.key === ' ') { e.preventDefault(); setOpen(o => !o); } }}
              tabIndex={0}
              role="button"
              aria-expanded={open}>
              {open ? '\u25BC' : '\u25B6'} DIPOLE CALCULATOR
            </div>
            <span style={{ position: 'relative', flexShrink: 0 }}>
              <span
                onClick={(e) => { e.stopPropagation(); setInfoOpen(o => !o); }}
                onKeyDown={(e) => { if (e.key === 'Enter' || e.key === ' ') { e.preventDefault(); setInfoOpen(o => !o); } }}
                tabIndex={0}
                role="button"
                aria-label="References"
                style={{ cursor: 'pointer', fontSize: 14, color: '#888', border: '1px solid #555',
                  borderRadius: '50%', width: 20, height: 20, display: 'inline-flex',
                  alignItems: 'center', justifyContent: 'center' }}>
                {'\u2139'}
              </span>
              {infoOpen && (
                <div style={{ position: 'absolute', top: 28, right: 0, background: '#2a2a2a',
                  border: '1px solid #555', borderRadius: 6, padding: '10px 14px', width: 280,
                  fontSize: 12, color: '#ccc', lineHeight: 1.5, zIndex: 200,
                  boxShadow: '0 4px 12px rgba(0,0,0,0.5)' }}>
                  Free-space impedance via the induced EMF method
                  (Stearns, K6OIK, {'\u201C'}Antenna Impedance Models,{'\u201D'} ARRL Pacificon 2004;
                  {' '}{'\u201C'}Dipole Basics,{'\u201D'} 2019). Ground effects via image theory with
                  Fresnel reflection (Balanis, <em>Antenna Theory</em>, 4e, Ch. 4 {'\u0026'} 8).
                  <div style={{ textAlign: 'right', marginTop: 6 }}>
                    <span onClick={() => setInfoOpen(false)}
                      onKeyDown={(e) => { if (e.key === 'Enter' || e.key === ' ') { e.preventDefault(); setInfoOpen(false); } }}
                      tabIndex={0} role="button" aria-label="Close references"
                      style={{ cursor: 'pointer', color: '#888', fontSize: 11 }}>close</span>
                  </div>
                </div>
              )}
            </span>
          </div>
          {open && (
            <>
              <div style={{ display: 'flex', gap: 12, marginBottom: 8, flexWrap: 'wrap' }}>
                <label style={{ display: 'flex', alignItems: 'center', gap: 4, fontSize: 14, color: '#888' }}>
                  Wire {'\u2300'} (mm):
                  <input type="number" value={state.elementDiamMm}
                    onChange={setStr('elementDiamMm')}
                    min="0.1" max="100" step="0.1"
                    style={{ width: 60, padding: '4px 6px', background: '#111', border: '1px solid #333', borderRadius: 4, color: '#aaa', fontFamily: 'inherit', fontSize: 13 }} />
                </label>
                <label style={{ display: 'flex', alignItems: 'center', gap: 4, fontSize: 14, color: '#888' }}>
                  Height (m):
                  <input type="number" value={state.heightM}
                    onChange={setStr('heightM')}
                    min="0.1" max="100" step="0.1"
                    style={{ width: 60, padding: '4px 6px', background: '#111', border: '1px solid #333', borderRadius: 4, color: '#aaa', fontFamily: 'inherit', fontSize: 13 }} />
                </label>
              </div>
              <div style={{ display: 'flex', gap: 4, flexWrap: 'wrap', marginBottom: 8 }}>
                {Object.entries(GROUND_TYPES).map(([key, { label }]) => (
                  <button key={key}
                    className={`btn preset-btn ${state.groundType === key ? 'active' : ''}`}
                    style={{ padding: '4px 8px', fontSize: 12 }}
                    onClick={() => set({ groundType: key })}
                    aria-label={`${label} ground`}>
                    {label}
                  </button>
                ))}
              </div>
              {groundZ && (
                <div style={{ fontSize: 13, color: '#4ade80', marginBottom: 4 }}>
                  <div>
                    {isFreeSpace
                      ? `Free-space resonant dipole: Z = ${groundZ.format()} \u03A9`
                      : `Over ${gndLabel.toLowerCase()} ground (h=${state.heightM}m): Z = ${groundZ.format()} \u03A9`}
                  </div>
                  <div style={{ color: '#888', fontSize: 12, marginTop: 6 }}>
                    Resonant length (K6OIK): {groundZ.lengthM.toFixed(3)} m
                    {' ('}K = {groundZ.K.toFixed(4)}
                    {omegaPrime != null && <>, {'\u03A9\u2032'} = {omegaPrime.toFixed(1)}</>}
                    {')'}
                  </div>
                </div>
              )}
              {hasFreqDiam && !groundZ && !isFreeSpace && (
                <div style={{ fontSize: 13, color: '#666', fontStyle: 'italic', marginBottom: 4 }}>
                  Enter height to compute impedance over ground
                </div>
              )}
              {(() => {
                const alreadyApplied = groundZ && impedanceKeys
                  && state[impedanceKeys.r] === Math.round(groundZ.r)
                  && state[impedanceKeys.x] === Math.round(groundZ.x)
                  && state._appliedCalcR === groundZ.r
                  && state._appliedCalcX === groundZ.x;
                return (
                  <button
                    className="btn auto-tune-btn ocfd"
                    style={{ marginTop: 4, width: '100%', opacity: groundZ && !alreadyApplied ? 1 : 0.4 }}
                    disabled={!groundZ || alreadyApplied}
                    onClick={() => groundZ && onApplyZ(groundZ)}
                    data-tooltip={alreadyApplied
                      ? 'Already applied'
                      : !groundZ
                        ? (() => {
                          const reasons = [
                            !(freq > 0) && 'frequency',
                            !(diam > 0) && 'wire diameter',
                            hasFreqDiam && !isFreeSpace && !hasHeight && 'height (or select free space)',
                          ].filter(Boolean);
                          return reasons.length > 0 ? `Enter ${reasons.join(', ')}` : 'Unable to compute impedance';
                        })()
                        : 'Set antenna impedance from calculated dipole Z'}
                  >
                    {alreadyApplied ? '\u2713 Applied' : 'Apply to Antenna Impedance'}
                  </button>
                );
              })()}
            </>
          )}
        </div>
      );
    };

    // ============================================================
    // Per-Mode Definitions
    // ============================================================

    /** Gamma match mode — all mode-specific behavior in one object */
    const gammaMode = {
      key: 'gamma',
      title: 'Gamma Match',
      buttonLabel: 'Gamma Match',
      activeClass: 'active-gamma',
      diagramTitle: 'GAMMA MATCH PHYSICAL ARRANGEMENT',
      hasAutoTune: true,
      presets: GAMMA_PRESETS,
      impedanceKeys: { r: 'antR', x: 'antX' },

      serializeUrl(p) {
        return {
          [URL_KEYS.antR]: Math.round(p.antR),
          [URL_KEYS.antX]: Math.round(p.antX),
          [URL_KEYS.tapRatio]: p.tapRatio.toFixed(2),
          [URL_KEYS.gammaRodX]: Math.round(p.gammaRodX),
          [URL_KEYS.seriesCapX]: Math.round(p.seriesCapX),
        };
      },

      tune(z) {
        const bounds = {
          tap: { min: 1, max: 2.5 },
          rod: { min: 20, max: 400 },
          cap: { min: 0, max: 100 }
        };
        const { tap: t, rod: rd, cap: c } = bounds;
        const result = fmin.nelderMead(([tap, rod, cap]) => {
          if (tap < t.min || tap > t.max || rod < rd.min || rod > rd.max || cap < c.min || cap > c.max) {
            return SWR_MAX;
          }
          const z1 = applyTapRatio(z, tap);
          const z2 = addShuntReactance(z1, rod);
          const z3 = addSeriesReactance(z2, -cap);
          return calcSWR(z3);
        }, [(t.min + t.max) / 2, (rd.min + rd.max) / 2, (c.min + c.max) / 2]);
        return {
          tapRatio: Math.round(result.x[0] * 100) / 100,
          gammaRodX: Math.round(result.x[1]),
          seriesCapX: Math.round(result.x[2])
        };
      },

      calc(p, zToScreen) {
        const antZ = Z(p.antR, p.antX);
        // Tap ratio path
        const tapPath = [];
        for (let i = 0; i <= PATH_STEPS; i++) {
          const ratio = 1 + (p.tapRatio - 1) * (i / PATH_STEPS);
          const z = applyTapRatio(antZ, ratio);
          if (z.r > 0 && z.r < PATH_R_MAX) {
            tapPath.push(zToScreen(z));
          }
        }
        const afterTap = applyTapRatio(antZ, p.tapRatio);
        // Shunt inductance arc along constant-G circle
        const shuntArc = calcShuntArc(afterTap, p.gammaRodX, zToScreen);
        // Series capacitor path
        const seriesPath = [];
        for (let i = 0; i <= PATH_STEPS; i++) {
          const xC = -p.seriesCapX * (i / PATH_STEPS);
          const z = addSeriesReactance(shuntArc.endZ, xC);
          seriesPath.push(zToScreen(z));
        }
        const finalZ = addSeriesReactance(shuntArc.endZ, -p.seriesCapX);
        return {
          origPt: zToScreen(antZ),
          afterTapPt: zToScreen(afterTap),
          afterShuntPt: shuntArc.endPt,
          finalPt: zToScreen(finalZ),
          afterTap,
          afterShunt: shuntArc.endZ,
          finalZ,
          tapPath,
          shuntArc,
          seriesPath,
          swr: calcSWR(finalZ)
        };
      },

      physical(p, base) {
        const capPf = p.seriesCapX > 0
          ? 1e12 / (2 * Math.PI * parseFloat(p.freqMHz) * 1e6 * p.seriesCapX)
          : null;
        const tapDistMm = (base.lambdaMm / (2 * Math.PI)) * Math.acos(1 / p.tapRatio);
        return { capPf, tapDistMm };
      },

      SmithOverlay: ({ result, state }) => (
        <>
          {/* Tap ratio path */}
          {result.tapPath.length > 1 && (
            <path
              d={pointsToPath(result.tapPath)}
              fill="none" stroke={COLORS.step1} strokeWidth="3" strokeDasharray="6,4" strokeLinecap="round"
            />
          )}
          {/* Shunt inductance path - true arc */}
          <path
            d={result.shuntArc.arcPath}
            fill="none" stroke={COLORS.step2} strokeWidth="3" strokeLinecap="round"
          />
          {/* Series capacitor path */}
          {result.seriesPath.length > 1 && (
            <path
              d={pointsToPath(result.seriesPath)}
              fill="none" stroke={COLORS.step3} strokeWidth="3" strokeLinecap="round"
            />
          )}
          {/* Arrows */}
          {result.tapPath.length > 3 && (
            <ArrowHead x={result.afterTapPt.x} y={result.afterTapPt.y}
              angle={getArrowAngle(result.tapPath, result.afterTapPt)} color={COLORS.step1} />
          )}
          <ArrowHead x={result.afterShuntPt.x} y={result.afterShuntPt.y}
            angle={result.shuntArc.arrowAngle} color={COLORS.step2} />
          {result.seriesPath.length > 3 && (
            <ArrowHead x={result.finalPt.x} y={result.finalPt.y}
              angle={getArrowAngle(result.seriesPath, result.finalPt)} color={COLORS.step3} />
          )}
          {/* Points */}
          <circle cx={result.origPt.x} cy={result.origPt.y} r="10" fill={COLORS.orig} stroke="#fff" strokeWidth="2" />
          <text x={result.origPt.x - 14} y={result.origPt.y - 14}
            fill={COLORS.orig} fontSize="11" fontWeight="600" textAnchor="end">
            {'\u2460'} {Z(state.antR, state.antX).formatLabel()}
          </text>
          <circle cx={result.afterTapPt.x} cy={result.afterTapPt.y} r="7" fill={COLORS.step1} stroke="#fff" strokeWidth="2" />
          <text x={result.afterTapPt.x + 12} y={result.afterTapPt.y - 8}
            fill={COLORS.step1} fontSize="10" fontWeight="600">
            {'\u2461'} {result.afterTap.formatLabel()}
          </text>
          <circle cx={result.afterShuntPt.x} cy={result.afterShuntPt.y} r="7" fill={COLORS.step2} stroke="#fff" strokeWidth="2" />
          <text x={result.afterShuntPt.x + 12} y={result.afterShuntPt.y - 8}
            fill={COLORS.step2} fontSize="10" fontWeight="600">
            {'\u2462'} {result.afterShunt.formatLabel()}
          </text>
          <circle cx={result.finalPt.x} cy={result.finalPt.y} r="10" fill={COLORS.final} stroke="#fff" strokeWidth="2" />
          <text x={result.finalPt.x + 14} y={result.finalPt.y + 4} fill={COLORS.final} fontSize="11" fontWeight="600">
            {'\u2463'} {result.finalZ.formatLabel()}
          </text>
        </>
      ),

      Controls: ({ state, result, physical, setNum, set, setStr, onApplyZ }) => (
        <>
          <ControlPanel color={COLORS.orig} title={'\u2460 ANTENNA IMPEDANCE'} tooltip="Starting impedance of the antenna feedpoint">
            <label className="control-label">
              <span className="control-text">Resistance: {state.antR}{'\u03A9'}</span>
              <input type="range" min="10" max="150" value={state.antR}
                onChange={setNum('antR')}
                aria-label="Antenna resistance"
                className="control-slider" style={{ accentColor: COLORS.orig }} />
            </label>
            <label className="control-label">
              <span className="control-text">
                Reactance: {state.antX >= 0 ? '+' : ''}j{state.antX}{'\u03A9'} {state.antX > 0 ? '(L)' : state.antX < 0 ? '(C)' : ''}
              </span>
              <input type="range" min="-100" max="100" value={state.antX}
                onChange={setNum('antX')}
                aria-label="Antenna reactance"
                className="control-slider" style={{ accentColor: COLORS.orig }} />
            </label>
            <div className="impedance-display">
              Z = {state.antR} {state.antX >= 0 ? '+' : '\u2212'} j{Math.abs(state.antX)} {'\u03A9'}
            </div>
          </ControlPanel>

          <DipoleCalculator state={state} set={set} setStr={setStr} onApplyZ={onApplyZ} impedanceKeys={gammaMode.impedanceKeys} />

          <ControlPanel color={COLORS.step1} title={'\u2461 AUTOTRANSFORMER (TAP RATIO)'} tooltip="Impedance step-up via tap position on driven element">
            <label className="control-label">
              <span className="control-text">n = {state.tapRatio.toFixed(2)} (Z {'\u00D7'} {(state.tapRatio * state.tapRatio).toFixed(2)})</span>
              <input type="range" min="1" max="2.5" step="0.01" value={state.tapRatio}
                onChange={setNum('tapRatio')}
                aria-label="Tap ratio"
                className="control-slider" style={{ accentColor: COLORS.step1 }} />
            </label>
            <div className="control-result">{'\u2192'} {result.afterTap.format()} {'\u03A9'}</div>
            {physical && (
              <div className="physical-hint">{'\u2248'} {Math.round(physical.tapDistMm)} mm from center</div>
            )}
          </ControlPanel>

          <ControlPanel color={COLORS.step2} title={'\u2462 GAMMA ROD (SHUNT +jX)'} tooltip="Parallel inductance from gamma rod coupling">
            <label className="control-label">
              <span className="control-text">Rod reactance: +j{state.gammaRodX}{'\u03A9'}</span>
              <input type="range" min="20" max="400" value={state.gammaRodX}
                onChange={setNum('gammaRodX')}
                aria-label="Gamma rod reactance"
                className="control-slider" style={{ accentColor: COLORS.step2 }} />
            </label>
            <div className="control-result">{'\u2192'} {result.afterShunt.format()} {'\u03A9'}</div>
          </ControlPanel>

          <ControlPanel color={COLORS.step3} title={'\u2463 SERIES CAPACITOR'} tooltip="Cancels inductive reactance to reach 50\u03A9">
            <label className="control-label">
              <span className="control-text">Cap reactance: {'\u2212'}j{state.seriesCapX}{'\u03A9'}</span>
              <input type="range" min="0" max="100" value={state.seriesCapX}
                onChange={setNum('seriesCapX')}
                aria-label="Series capacitor reactance"
                className="control-slider" style={{ accentColor: COLORS.step3 }} />
            </label>
            {physical && physical.capPf && (
              <div className="physical-hint">{'\u2248'} {Math.round(physical.capPf)} pF at {state.freqMHz} MHz</div>
            )}
          </ControlPanel>

          <div className={`result-panel ${result.swr < 1.5 ? 'good' : 'normal'}`}
            style={{ borderColor: result.swr < 1.5 ? COLORS.hairpin : COLORS.final }}
            aria-live="polite">
            <div className="control-header" style={{ color: COLORS.final }}>MATCHED IMPEDANCE</div>
            <div className="result-z">Z = {result.finalZ.format()} {'\u03A9'}</div>
            <div className={`result-swr ${getSWRClass(result.swr)}`}>
              SWR = {result.swr.toFixed(3)} : 1
            </div>
          </div>
        </>
      ),

      Diagram: () => (
        <svg viewBox="0 0 450 150" className="diagram-svg">
          {/* Driven element */}
          <line x1="30" y1="28" x2="420" y2="28" stroke={COLORS.element} strokeWidth="6" strokeLinecap="round" />
          <text x="100" y="16" fill={COLORS.element} fontSize="10" textAnchor="middle">Driven Element ≈ λ/2</text>
          {/* A — element center (shield connects here) */}
          <circle cx="190" cy="28" r="3" fill={COLORS.coax} />
          <text x="190" y="19" fill={COLORS.coax} fontSize="9" textAnchor="middle">A</text>
          {/* B — tap point on element */}
          <circle cx="315" cy="28" r="4" fill={COLORS.step1} />
          <text x="315" y="18" fill={COLORS.step1} fontSize="9" textAnchor="middle">B</text>
          {/* Coax shield (outer conductor) — both walls start at dot level */}
          <line x1="190" y1="75" x2="190" y2="120" stroke={COLORS.coax} strokeWidth="2.5" />
          {/* Right wall — starts below center conductor exit */}
          <line x1="202" y1="75" x2="202" y2="120" stroke={COLORS.coax} strokeWidth="2.5" />
          <line x1="190" y1="120" x2="202" y2="120" stroke={COLORS.coax} strokeWidth="2.5" />
          {/* Shield wire from coax top up to element at A */}
          <line x1="190" y1="75" x2="190" y2="31" stroke={COLORS.wire} strokeWidth="2.5" />
          {/* Coax top ellipse */}
          <ellipse cx="196" cy="75" rx="6" ry="3" fill="#1a1a2e" stroke={COLORS.coax} strokeWidth="1.5" />
          {/* Connection dot where shield wire meets coax */}
          <circle cx="190" cy="75" r="3" fill={COLORS.wire} />
          {/* Center conductor inside coax — drawn on top of ellipse */}
          <line x1="196" y1="70" x2="196" y2="118" stroke="#bbb" strokeWidth="1.5" />
          {/* Center conductor exits coax right to cap C */}
          <line x1="196" y1="70" x2="216" y2="70" stroke="#bbb" strokeWidth="1.5" />
          {/* Series capacitor C (left of gamma rod) */}
          <line x1="216" y1="62" x2="216" y2="78" stroke={COLORS.step3} strokeWidth="2" />
          <line x1="222" y1="62" x2="222" y2="78" stroke={COLORS.step3} strokeWidth="2" />
          <text x="219" y="90" fill={COLORS.step3} fontSize="9" textAnchor="middle">C</text>
          {/* Wire from cap to gamma rod */}
          <line x1="222" y1="70" x2="232" y2="70" stroke={COLORS.wire} strokeWidth="2" />
          {/* Gamma rod from after cap rightward to tap */}
          <line x1="232" y1="70" x2="315" y2="70" stroke={COLORS.step2} strokeWidth="4" strokeLinecap="round" />
          <text x="270" y="62" fill={COLORS.step2} fontSize="9" textAnchor="middle">Gamma Rod (+jX)</text>
          {/* Vertical from gamma rod end up to tap point B */}
          <line x1="315" y1="70" x2="315" y2="28" stroke={COLORS.step1} strokeWidth="2" />
          <text x="324" y="50" fill={COLORS.step1} fontSize="8">tap</text>
          {/* Coax label */}
          <text x="196" y="134" fill={COLORS.coax} fontSize="9" textAnchor="middle">50Ω</text>
        </svg>
      ),

      Legend: () => (
        <>
          <line x1="0" y1="0" x2="20" y2="0" stroke={COLORS.step1} strokeWidth="3" strokeDasharray="6,4" />
          <text x="26" y="4" fill={COLORS.step1} fontSize="9">{'\u2461'} Autotransformer</text>
          <line x1="0" y1="16" x2="20" y2="16" stroke={COLORS.step2} strokeWidth="3" />
          <text x="26" y="20" fill={COLORS.step2} fontSize="9">{'\u2462'} Shunt L</text>
          <line x1="0" y1="32" x2="20" y2="32" stroke={COLORS.step3} strokeWidth="3" />
          <text x="26" y="36" fill={COLORS.step3} fontSize="9">{'\u2463'} Series C</text>
        </>
      ),

      Info: () => (
        <div className="info">
          <strong>Gamma Match:</strong> Uses tap ratio to scale Z, shunt inductor (gamma rod), and series capacitor.
          Works for both high-Z and low-Z antennas by adjusting the tap position.
        </div>
      ),
    };

    /** Hairpin/beta match mode — all mode-specific behavior in one object */
    const hairpinMode = {
      key: 'hairpin',
      title: 'Beta (Hairpin) Match',
      buttonLabel: 'Beta (Hairpin) Match',
      activeClass: 'active-hairpin',
      diagramTitle: 'BETA (HAIRPIN) MATCH PHYSICAL ARRANGEMENT',
      hasAutoTune: true,
      presets: HAIRPIN_PRESETS,
      impedanceKeys: { r: 'antR', x: 'antX' },

      serializeUrl(p) {
        return {
          [URL_KEYS.antR]: Math.round(p.antR),
          [URL_KEYS.antX]: Math.round(p.antX),
          [URL_KEYS.shortening]: Math.round(p.shortening),
          [URL_KEYS.hairpinX]: Math.round(p.hairpinX),
        };
      },

      tune(z) {
        const bounds = {
          shorten: { min: 0, max: 60 },
          hp: { min: 15, max: 200 }
        };
        const { shorten: s, hp: h } = bounds;
        const result = fmin.nelderMead(([shorten, hp]) => {
          if (shorten < s.min || shorten > s.max || hp < h.min || hp > h.max) {
            return SWR_MAX;
          }
          const z1 = Z(z.r, z.x - shorten);
          const z2 = addShuntReactance(z1, hp);
          return calcSWR(z2);
        }, [(s.min + s.max) / 2, (h.min + h.max) / 2]);
        return {
          shortening: Math.round(result.x[0]),
          hairpinX: Math.round(result.x[1])
        };
      },

      calc(p, zToScreen) {
        const antZ = Z(p.antR, p.antX);
        // Shortening path
        const shortenPath = [];
        for (let i = 0; i <= PATH_STEPS; i++) {
          const z = Z(p.antR, p.antX - p.shortening * (i / PATH_STEPS));
          shortenPath.push(zToScreen(z));
        }
        const afterShorten = Z(p.antR, p.antX - p.shortening);
        // Hairpin inductance arc along constant-G circle
        const hpArc = calcShuntArc(afterShorten, p.hairpinX, zToScreen);
        return {
          origPt: zToScreen(antZ),
          shortenedPt: zToScreen(afterShorten),
          finalPt: hpArc.endPt,
          afterShorten,
          finalZ: hpArc.endZ,
          shortenPath,
          hpArc,
          swr: calcSWR(hpArc.endZ)
        };
      },

      physical(p, base) {
        const diam = parseFloat(p.elementDiamMm);
        let shortenMm = null;
        let shortenPct = null;
        if (diam && diam > 0) {
          // Schelkunoff average characteristic impedance: Z₀ = 120·(ln(2h/a) − 1)
          // where h = λ/4 (half-length), a = d/2 (wire radius)
          const halfLen = base.lambdaMm / 4;
          const wireRadius = diam / 2;
          const z0Ant = 120 * (Math.log(2 * halfLen / wireRadius) - 1);
          const deltaLOverLambda = p.shortening / (z0Ant * Math.PI);
          shortenMm = deltaLOverLambda * base.lambdaMm / 2;
          shortenPct = (deltaLOverLambda / 0.5) * 100;
        }
        return { shortenMm, shortenPct };
      },

      SmithOverlay: ({ result, state }) => (
        <>
          {/* Shortening path */}
          {result.shortenPath.length > 1 && (
            <path
              d={pointsToPath(result.shortenPath)}
              fill="none" stroke={COLORS.step1} strokeWidth="3" strokeDasharray="6,4" strokeLinecap="round"
            />
          )}
          {/* Hairpin path - true arc */}
          <path
            d={result.hpArc.arcPath}
            fill="none" stroke={COLORS.hairpin} strokeWidth="3" strokeLinecap="round"
          />
          {/* Arrows */}
          {result.shortenPath.length > 3 && (
            <ArrowHead x={result.shortenedPt.x} y={result.shortenedPt.y}
              angle={getArrowAngle(result.shortenPath, result.shortenedPt)} color={COLORS.step1} />
          )}
          <ArrowHead x={result.finalPt.x} y={result.finalPt.y}
            angle={result.hpArc.arrowAngle} color={COLORS.hairpin} />
          {/* Points */}
          <circle cx={result.origPt.x} cy={result.origPt.y} r="10" fill={COLORS.orig} stroke="#fff" strokeWidth="2" />
          <text x={result.origPt.x + 14} y={result.origPt.y + 4}
            fill={COLORS.orig} fontSize="11" fontWeight="600">
            {'\u2460'} {Z(state.antR, state.antX).formatLabel()}
          </text>
          <circle cx={result.shortenedPt.x} cy={result.shortenedPt.y} r="7" fill={COLORS.step1} stroke="#fff" strokeWidth="2" />
          <text x={result.shortenedPt.x + 12} y={result.shortenedPt.y - 8}
            fill={COLORS.step1} fontSize="10" fontWeight="600">
            {'\u2461'} {result.afterShorten.formatLabel()}
          </text>
          <circle cx={result.finalPt.x} cy={result.finalPt.y} r="10" fill={COLORS.final} stroke="#fff" strokeWidth="2" />
          <text x={result.finalPt.x + 14} y={result.finalPt.y + 4} fill={COLORS.final} fontSize="11" fontWeight="600">
            {'\u2462'} {result.finalZ.formatLabel()}
          </text>
        </>
      ),

      Controls: ({ state, result, physical, setNum, set, setStr, onApplyZ }) => (
        <>
          <ControlPanel color={COLORS.orig} title={'\u2460 ANTENNA IMPEDANCE'} tooltip="Starting impedance of the antenna feedpoint">
            <label className="control-label">
              <span className="control-text">Resistance: {state.antR}{'\u03A9'}</span>
              <input type="range" min="10" max="150" value={state.antR}
                onChange={setNum('antR')}
                aria-label="Antenna resistance"
                className="control-slider" style={{ accentColor: COLORS.orig }} />
            </label>
            <label className="control-label">
              <span className="control-text">
                Reactance: {state.antX >= 0 ? '+' : ''}j{state.antX}{'\u03A9'} {state.antX > 0 ? '(L)' : state.antX < 0 ? '(C)' : ''}
              </span>
              <input type="range" min="-100" max="100" value={state.antX}
                onChange={setNum('antX')}
                aria-label="Antenna reactance"
                className="control-slider" style={{ accentColor: COLORS.orig }} />
            </label>
            <div className="impedance-display">
              Z = {state.antR} {state.antX >= 0 ? '+' : '\u2212'} j{Math.abs(state.antX)} {'\u03A9'}
            </div>
          </ControlPanel>

          <DipoleCalculator state={state} set={set} setStr={setStr} onApplyZ={onApplyZ} impedanceKeys={hairpinMode.impedanceKeys} />

          <ControlPanel color={COLORS.step1} title={'\u2461 SHORTEN ELEMENT'} tooltip="Capacitive reactance from shortened driven element">
            <label className="control-label">
              <span className="control-text">Capacitive reactance: {'\u2212'}j{state.shortening}{'\u03A9'}</span>
              <input type="range" min="0" max="60" value={state.shortening}
                onChange={setNum('shortening')}
                aria-label="Element shortening reactance"
                className="control-slider" style={{ accentColor: COLORS.step1 }} />
            </label>
            <div className="control-result">{'\u2192'} {result.afterShorten.format()} {'\u03A9'}</div>
            {physical && physical.shortenMm !== null ? (
              <div className="physical-hint">
                {'\u2248'} {physical.shortenMm.toFixed(1)} mm per side ({physical.shortenPct.toFixed(1)}% of {'\u03BB'}/2)
              </div>
            ) : (
              <div className="control-hint">Constant-R circle (series reactance)</div>
            )}
          </ControlPanel>

          <ControlPanel color={COLORS.hairpin} title={'\u2462 HAIRPIN (PARALLEL +jX)'} tooltip="Shunt inductor transforms impedance up to 50\u03A9">
            <label className="control-label">
              <span className="control-text">Inductive reactance: +j{state.hairpinX}{'\u03A9'}</span>
              <input type="range" min="15" max="200" value={state.hairpinX}
                onChange={setNum('hairpinX')}
                aria-label="Hairpin reactance"
                className="control-slider" style={{ accentColor: COLORS.hairpin }} />
            </label>
            <div className="control-hint">Constant-G circle (shunt susceptance)</div>
          </ControlPanel>

          <div className={`result-panel ${result.swr < 1.5 ? 'good' : 'normal'}`}
            style={{ borderColor: result.swr < 1.5 ? COLORS.hairpin : COLORS.final }}
            aria-live="polite">
            <div className="control-header" style={{ color: COLORS.final }}>MATCHED IMPEDANCE</div>
            <div className="result-z">Z = {result.finalZ.format()} {'\u03A9'}</div>
            <div className={`result-swr ${getSWRClass(result.swr)}`}>
              SWR = {result.swr.toFixed(3)} : 1
            </div>
          </div>
        </>
      ),

      Diagram: () => (
        <svg viewBox="0 0 450 130" className="diagram-svg">
          {/* Driven element - split with gap */}
          <line x1="50" y1="50" x2="212" y2="50" stroke={COLORS.element} strokeWidth="6" strokeLinecap="round" />
          <line x1="238" y1="50" x2="400" y2="50" stroke={COLORS.element} strokeWidth="6" strokeLinecap="round" />
          <text x="131" y="35" fill={COLORS.element} fontSize="10" textAnchor="middle">&lt; λ/4</text>
          <text x="319" y="35" fill={COLORS.element} fontSize="10" textAnchor="middle">&lt; λ/4</text>
          <path d="M 215 56 L 215 90 Q 215 100 225 100 Q 235 100 235 90 L 235 56"
            fill="none" stroke={COLORS.hairpin} strokeWidth="4" strokeLinecap="round" />
          <text x="225" y="118" fill={COLORS.hairpin} fontSize="9" textAnchor="middle">Hairpin (+jX)</text>
          <line x1="215" y1="56" x2="150" y2="56" stroke={COLORS.wire} strokeWidth="2" />
          <line x1="235" y1="56" x2="235" y2="70" stroke={COLORS.wire} strokeWidth="2" />
          <line x1="235" y1="70" x2="150" y2="70" stroke={COLORS.wire} strokeWidth="2" />
          <line x1="150" y1="56" x2="150" y2="70" stroke={COLORS.coax} strokeWidth="3" />
          <line x1="150" y1="63" x2="100" y2="63" stroke={COLORS.coax} strokeWidth="3" />
          <text x="75" y="67" fill={COLORS.coax} fontSize="9" textAnchor="middle">50Ω</text>
        </svg>
      ),

      Legend: () => (
        <>
          <line x1="0" y1="0" x2="20" y2="0" stroke={COLORS.step1} strokeWidth="3" strokeDasharray="6,4" />
          <text x="26" y="4" fill={COLORS.step1} fontSize="9">{'\u2461'} Shorten</text>
          <line x1="0" y1="16" x2="20" y2="16" stroke={COLORS.hairpin} strokeWidth="3" />
          <text x="26" y="20" fill={COLORS.hairpin} fontSize="9">{'\u2462'} Hairpin</text>
        </>
      ),

      Info: () => (
        <div className="info">
          <strong>Beta (Hairpin) Match:</strong> Shorten the driven element to add capacitive reactance,
          then use a parallel inductor (hairpin) to transform up to 50{'\u03A9'}. Best for low-Z antennas like Yagis.
        </div>
      ),
    };

    /** OCFD mode — all mode-specific behavior in one object */
    const ocfdMode = {
      key: 'ocfd',
      title: 'Off-Center Fed Doublet',
      buttonLabel: 'OCFD',
      activeClass: 'active-ocfd',
      diagramTitle: 'OFF-CENTER FED DOUBLET',
      hasAutoTune: false,
      presets: OCFD_PRESETS,
      impedanceKeys: { r: 'ocfdR', x: 'ocfdX' },

      serializeUrl(p) {
        return {
          [URL_KEYS.ocfdR]: Math.round(p.ocfdR),
          [URL_KEYS.ocfdX]: Math.round(p.ocfdX),
          [URL_KEYS.feedOffset]: Math.round(p.feedOffset),
          [URL_KEYS.feedlineZ0]: p.feedlineZ0,
        };
      },

      tune: null,

      calc(p, zToScreen) {
        const centerZ = Z(p.ocfdR, p.ocfdX);
        const z0 = p.feedlineZ0;
        const alpha = p.feedOffset / 100;
        const factor = 1 / Math.cos(Math.PI * alpha) ** 2;
        const feedZ = Z(p.ocfdR * factor, p.ocfdX * factor);
        const centerPt = zToScreen(centerZ);
        const feedPt = zToScreen(feedZ);
        // Trajectory path: impedance as offset sweeps from 0 to current value
        const trajectoryPath = [];
        for (let i = 0; i <= PATH_STEPS; i++) {
          const a = alpha * (i / PATH_STEPS);
          const f = 1 / Math.cos(Math.PI * a) ** 2;
          const z = Z(p.ocfdR * f, p.ocfdX * f);
          if (z.r > 0 && z.r < PATH_R_MAX) {
            trajectoryPath.push(zToScreen(z));
          }
        }
        const swrs = FEEDLINE_IMPEDANCES.map(fl => ({
          z0: fl,
          swr: calcSWRForZ0(feedZ, fl)
        }));
        const selectedSwr = calcSWRForZ0(feedZ, z0);
        return { centerZ, feedZ, centerPt, feedPt, swrs, swr: selectedSwr, z0, trajectoryPath };
      },

      physical(p, base) {
        const alpha = p.feedOffset / 100;
        const halfDipole = base.lambdaMm / 2;
        return {
          ocfdL1Mm: halfDipole * (0.5 - alpha),
          ocfdL2Mm: halfDipole * (0.5 + alpha),
        };
      },

      SmithOverlay: ({ result }) => (
        <>
          {/* Trajectory path from center to feed point */}
          {result.trajectoryPath.length > 1 && (
            <path
              d={pointsToPath(result.trajectoryPath)}
              fill="none" stroke={COLORS.ocfd} strokeWidth="2" strokeDasharray="4,3" strokeLinecap="round" opacity="0.6"
            />
          )}
          {/* Center impedance point */}
          <circle cx={result.centerPt.x} cy={result.centerPt.y} r="8" fill={COLORS.orig} stroke="#fff" strokeWidth="2" />
          <text x={result.centerPt.x - 14} y={result.centerPt.y - 12}
            fill={COLORS.orig} fontSize="10" fontWeight="600" textAnchor="end">
            {'\u2460'} {result.centerZ.formatLabel()}
          </text>
          {/* Feed impedance point */}
          <circle cx={result.feedPt.x} cy={result.feedPt.y} r="10" fill={COLORS.ocfd} stroke="#fff" strokeWidth="2" />
          <text x={result.feedPt.x + 14} y={result.feedPt.y + 4}
            fill={COLORS.ocfd} fontSize="11" fontWeight="600">
            {'\u2461'} {result.feedZ.formatLabel()}
          </text>
        </>
      ),

      Controls: ({ state, result, physical, setNum, set, setStr, onApplyZ }) => (
          <>
            <ControlPanel color={COLORS.orig} title={'\u2460 ANTENNA IMPEDANCE (CENTER FED)'} tooltip="Impedance at the center of the dipole (source of truth for matching)">
              <label className="control-label">
                <span className="control-text">Resistance: {state.ocfdR}{'\u03A9'}</span>
                <input type="range" min="10" max="150" value={state.ocfdR}
                  onChange={setNum('ocfdR')}
                  aria-label="OCFD center resistance"
                  className="control-slider" style={{ accentColor: COLORS.orig }} />
              </label>
              <label className="control-label">
                <span className="control-text">
                  Reactance: {state.ocfdX >= 0 ? '+' : ''}j{state.ocfdX}{'\u03A9'} {state.ocfdX > 0 ? '(L)' : state.ocfdX < 0 ? '(C)' : ''}
                </span>
                <input type="range" min="-100" max="100" value={state.ocfdX}
                  onChange={setNum('ocfdX')}
                  aria-label="OCFD center reactance"
                  className="control-slider" style={{ accentColor: COLORS.orig }} />
              </label>
              <div className="impedance-display">
                Z{'\u2080'} = {state.ocfdR} {state.ocfdX >= 0 ? '+' : '\u2212'} j{Math.abs(state.ocfdX)} {'\u03A9'}
              </div>
            </ControlPanel>

            <DipoleCalculator state={state} set={set} setStr={setStr} onApplyZ={onApplyZ} impedanceKeys={ocfdMode.impedanceKeys} />

            <ControlPanel color={COLORS.ocfd} title={'\u2461 FEED OFFSET'} tooltip="Distance from center as % of half-length">
              <label className="control-label">
                <span className="control-text">Offset: {state.feedOffset}% from center</span>
                <input type="range" min="0" max="50" step="1" value={state.feedOffset}
                  onChange={setNum('feedOffset')}
                  aria-label="Feed offset"
                  className="control-slider" style={{ accentColor: COLORS.ocfd }} />
              </label>
              {physical && (
                <div className="physical-hint">
                  L{'\u2081'} = {physical.ocfdL1Mm >= 1000 ? (physical.ocfdL1Mm / 1000).toFixed(2) + 'm' : Math.round(physical.ocfdL1Mm) + 'mm'}
                  {' / '}
                  L{'\u2082'} = {physical.ocfdL2Mm >= 1000 ? (physical.ocfdL2Mm / 1000).toFixed(2) + 'm' : Math.round(physical.ocfdL2Mm) + 'mm'}
                </div>
              )}
            </ControlPanel>

            <ControlPanel color={COLORS.ocfd} title="FEEDLINE IMPEDANCE" tooltip="Characteristic impedance of the feedline">
              <div className="feedline-selector">
                {FEEDLINE_IMPEDANCES.map(z0 => (
                  <button
                    key={z0}
                    className={`btn preset-btn ${state.feedlineZ0 === z0 ? 'active' : ''}`}
                    onClick={() => set({ feedlineZ0: z0 })}
                    aria-label={`${z0} ohm feedline`}
                  >
                    {z0}{'\u03A9'}
                  </button>
                ))}
              </div>
            </ControlPanel>

            <div className="result-panel normal" style={{ borderColor: COLORS.ocfd }} aria-live="polite">
              <div className="control-header" style={{ color: COLORS.ocfd }}>FEED IMPEDANCE</div>
              <div className="result-z">Z = {result.feedZ.format()} {'\u03A9'}</div>
              <div className="result-swr" style={{ marginBottom: 6 }}>
                <span className={getSWRClass(result.swr)}>
                  SWR ({state.feedlineZ0}{'\u03A9'}) = {result.swr.toFixed(3)} : 1
                </span>
              </div>
              <div className="swr-table">
                {result.swrs.filter(s => s.z0 !== state.feedlineZ0).map(({ z0, swr }) => (
                  <div key={z0} className="swr-row">
                    <span className="swr-row-label">{z0}{'\u03A9'} line:</span>
                    <span className={`swr-row-value ${getSWRClass(swr)}`}>
                      SWR = {swr.toFixed(2)} : 1
                    </span>
                  </div>
                ))}
              </div>
            </div>
          </>
      ),

      Diagram: ({ state, physical }) => {
        const alpha = state.feedOffset / 100;
        const wireLeft = 50;
        const wireRight = 400;
        const wireLen = wireRight - wireLeft;
        const wireCenter = (wireLeft + wireRight) / 2;
        const wireY = 50;
        // Feed moves right; L1 (left of feed) is long, L2 (right) is short
        const feedX = wireCenter + alpha * wireLen;
        const feedXClamped = Math.min(feedX, wireRight);
        return (
          <svg viewBox="0 0 450 130" className="diagram-svg">
            {/* Full dipole wire */}
            <line x1={wireLeft} y1={wireY} x2={wireRight} y2={wireY}
              stroke={COLORS.element} strokeWidth="6" strokeLinecap="round" />
            {/* Center marker */}
            <circle cx={wireCenter} cy={wireY} r="3" fill="#333" />
            <text x={wireCenter} y={wireY - 10} fill="#555" fontSize="9" textAnchor="middle">center</text>
            {/* Feed point */}
            <circle cx={feedXClamped} cy={wireY} r="5" fill={COLORS.ocfd} />
            {/* Feedline dropping down */}
            <line x1={feedXClamped} y1={wireY} x2={feedXClamped} y2={95}
              stroke={COLORS.coax} strokeWidth="3" />
            <text x={feedXClamped} y={110} fill={COLORS.coax} fontSize="9" textAnchor="middle">Feedline</text>
            {/* L2 label (long side = left of feed) */}
            <line x1={wireLeft} y1={wireY + 20} x2={feedXClamped} y2={wireY + 20}
              stroke={COLORS.ocfd} strokeWidth="1" />
            <line x1={wireLeft} y1={wireY + 16} x2={wireLeft} y2={wireY + 24}
              stroke={COLORS.ocfd} strokeWidth="1" />
            <line x1={feedXClamped} y1={wireY + 16} x2={feedXClamped} y2={wireY + 24}
              stroke={COLORS.ocfd} strokeWidth="1" />
            <text x={(wireLeft + feedXClamped) / 2} y={wireY + 34}
              fill={COLORS.ocfd} fontSize="9" textAnchor="middle">
              {physical ? `L₂ = ${physical.ocfdL2Mm >= 1000 ? (physical.ocfdL2Mm / 1000).toFixed(2) + 'm' : Math.round(physical.ocfdL2Mm) + 'mm'}` : 'L₂ (long)'}
            </text>
            {/* L1 label (short side = right of feed) */}
            <line x1={feedXClamped} y1={wireY + 20} x2={wireRight} y2={wireY + 20}
              stroke={COLORS.orig} strokeWidth="1" />
            <line x1={feedXClamped} y1={wireY + 16} x2={feedXClamped} y2={wireY + 24}
              stroke={COLORS.orig} strokeWidth="1" />
            <line x1={wireRight} y1={wireY + 16} x2={wireRight} y2={wireY + 24}
              stroke={COLORS.orig} strokeWidth="1" />
            <text x={(feedXClamped + wireRight) / 2} y={wireY + 34}
              fill={COLORS.orig} fontSize="9" textAnchor="middle">
              {physical ? `L₁ = ${physical.ocfdL1Mm >= 1000 ? (physical.ocfdL1Mm / 1000).toFixed(2) + 'm' : Math.round(physical.ocfdL1Mm) + 'mm'}` : 'L₁ (short)'}
            </text>
            {/* Total length */}
            <text x={wireCenter} y={wireY - 26} fill={COLORS.element} fontSize="10" textAnchor="middle">
              {physical ? `Dipole ≈ ${(physical.lambdaMm / 2000).toFixed(2)}m (λ/2)` : 'Dipole ≈ λ/2'}
            </text>
            {/* Offset label */}
            <text x={feedXClamped} y={wireY - 10} fill={COLORS.ocfd} fontSize="9" textAnchor="middle">
              {state.feedOffset}% off-center
            </text>
          </svg>
        );
      },

      Legend: () => (
        <>
          <circle cx="5" cy="0" r="5" fill={COLORS.orig} />
          <text x="16" y="4" fill={COLORS.orig} fontSize="9">{'\u2460'} Center Z</text>
          <line x1="0" y1="16" x2="10" y2="16" stroke={COLORS.ocfd} strokeWidth="2" strokeDasharray="4,3" />
          <text x="16" y="20" fill={COLORS.ocfd} fontSize="9">Offset trajectory</text>
          <circle cx="5" cy="32" r="5" fill={COLORS.ocfd} />
          <text x="16" y="36" fill={COLORS.ocfd} fontSize="9">{'\u2461'} Feed Z</text>
        </>
      ),

      Info: () => (
        <div className="info">
          <strong>Off-Center Fed Doublet:</strong> A half-wave dipole fed off-center presents higher impedance,
          enabling use with 300{'\u03A9'} or 450{'\u03A9'} balanced feedline.
          Z{'\u2090'}({'\u03B1'}) = Z{'\u2080'} / cos{'\u00B2'}({'\u03C0\u03B1'}) where {'\u03B1'} is the feed offset ratio.
        </div>
      ),
    };

    /** @type {Object} Per-mode object map */
    const MODE_MAP = Object.freeze({
      [MODES.GAMMA]: gammaMode,
      [MODES.HAIRPIN]: hairpinMode,
      [MODES.OCFD]: ocfdMode,
    });

    /**
     * Calculate base physical parameters from frequency
     * @param {string} freqMHz - Frequency in MHz
     * @returns {Object|null} { lambda, lambdaMm } or null if no valid frequency
     */
    const calcBasePhysical = (freqMHz) => {
      const freq = parseFloat(freqMHz);
      if (!freq || freq <= 0) return null;
      const lambda = C_SPEED / (freq * 1e6);
      return { lambda, lambdaMm: lambda * 1000 };
    };

    // ============================================================
    // URL Parameter Utilities
    // ============================================================

    /**
     * Parse float from URL param with default
     * @param {string|null} val - URL parameter value
     * @param {number} def - Default value
     * @returns {number}
     */
    const parseParam = (val, def) => {
      if (val === null) return def;
      const n = parseFloat(val);
      return isNaN(n) ? def : n;
    };

    /** @type {Object} Default parameter values */
    const DEFAULTS = Object.freeze({
      mode: MODES.GAMMA,
      antR: 73,
      antX: 43,
      tapRatio: 1.0,
      gammaRodX: 300,
      seriesCapX: 30,
      shortening: 15,
      hairpinX: 50,
      freqMHz: '',
      elementDiamMm: '2',
      ocfdR: 73,
      ocfdX: 43,
      feedOffset: 0,
      feedlineZ0: 50,
      heightM: '',
      groundType: 'average',
      calcOpen: 0
    });

    /**
     * Check if all values match defaults
     * @param {Object} values - Current state values
     * @returns {boolean}
     */
    const isAtDefaults = (values) =>
      Object.keys(DEFAULTS).every(key => values[key] === DEFAULTS[key]);

    /**
     * Read initial state from URL parameters
     * @returns {Object} Initial state values from URL
     */
    const getUrlParams = () => {
      const params = new URLSearchParams(window.location.search);
      const modeParam = params.get(URL_KEYS.mode);
      return {
        mode: Object.values(MODES).includes(modeParam) ? modeParam : DEFAULTS.mode,
        antR: parseParam(params.get(URL_KEYS.antR), DEFAULTS.antR),
        antX: parseParam(params.get(URL_KEYS.antX), DEFAULTS.antX),
        tapRatio: parseParam(params.get(URL_KEYS.tapRatio), DEFAULTS.tapRatio),
        gammaRodX: parseParam(params.get(URL_KEYS.gammaRodX), DEFAULTS.gammaRodX),
        seriesCapX: parseParam(params.get(URL_KEYS.seriesCapX), DEFAULTS.seriesCapX),
        shortening: parseParam(params.get(URL_KEYS.shortening), DEFAULTS.shortening),
        hairpinX: parseParam(params.get(URL_KEYS.hairpinX), DEFAULTS.hairpinX),
        freqMHz: params.get(URL_KEYS.freqMHz) || DEFAULTS.freqMHz,
        elementDiamMm: params.get(URL_KEYS.elementDiamMm) || DEFAULTS.elementDiamMm,
        ocfdR: parseParam(params.get(URL_KEYS.ocfdR), DEFAULTS.ocfdR),
        ocfdX: parseParam(params.get(URL_KEYS.ocfdX), DEFAULTS.ocfdX),
        feedOffset: parseParam(params.get(URL_KEYS.feedOffset), DEFAULTS.feedOffset),
        feedlineZ0: parseParam(params.get(URL_KEYS.feedlineZ0), DEFAULTS.feedlineZ0),
        heightM: params.get(URL_KEYS.heightM) || DEFAULTS.heightM,
        groundType: (params.get(URL_KEYS.groundType) in GROUND_TYPES)
          ? params.get(URL_KEYS.groundType) : DEFAULTS.groundType,
        calcOpen: 0
      };
    };

    const initialParams = getUrlParams();

    /**
     * Get CSS class for SWR value
     * @param {number} swr - Standing wave ratio
     * @returns {string} CSS class name
     */
    const getSWRClass = (swr) => {
      if (swr < SWR_THRESHOLDS.excellent) return 'swr-excellent';
      if (swr < SWR_THRESHOLDS.good) return 'swr-good';
      if (swr < SWR_THRESHOLDS.ok) return 'swr-ok';
      return 'swr-poor';
    };

    // ============================================================
    // Main Component
    // ============================================================

    function AntennaMatching() {
      const [p, setP] = useState(initialParams);
      const set = (updates) => setP(prev => ({ ...prev, ...updates }));

      /** Helper for numeric input onChange handlers */
      const setNum = (key) => (e) => set({ [key]: Number(e.target.value) });

      /** Helper for string input onChange handlers */
      const setStr = (key) => (e) => set({ [key]: e.target.value });

      const { mode, freqMHz } = p;
      const modeDef = MODE_MAP[mode];

      // Update URL when state changes
      useEffect(() => {
        if (isAtDefaults(p)) {
          window.history.replaceState(null, '', window.location.pathname);
          return;
        }

        const params = new URLSearchParams();
        params.set(URL_KEYS.mode, p.mode);
        const modeParams = modeDef.serializeUrl(p);
        Object.entries(modeParams).forEach(([k, v]) => params.set(k, v));
        if (p.freqMHz) params.set(URL_KEYS.freqMHz, p.freqMHz);
        if (p.elementDiamMm && p.elementDiamMm !== DEFAULTS.elementDiamMm) params.set(URL_KEYS.elementDiamMm, p.elementDiamMm);
        if (p.heightM) params.set(URL_KEYS.heightM, p.heightM);
        if (p.groundType !== DEFAULTS.groundType) params.set(URL_KEYS.groundType, p.groundType);

        const newUrl = `${window.location.pathname}?${params.toString()}`;
        window.history.replaceState(null, '', newUrl);
      }, [p]);

      // Hooks
      const { zToScreen, rCircles, xArcs, createXArc } = useSmithChart();
      const result = useMemo(() => modeDef.calc(p, zToScreen), [modeDef, p, zToScreen]);
      const didAutoTune = useRef(false);

      // Physical calculations (shared base + mode-specific)
      const physical = useMemo(() => {
        const base = calcBasePhysical(freqMHz);
        return base ? { ...base, ...modeDef.physical(p, base) } : null;
      }, [modeDef, p, freqMHz]);

      const handleAutoTune = useCallback(() => {
        if (modeDef.tune) {
          const { r: rKey, x: xKey } = modeDef.impedanceKeys;
          setP(prev => {
            const tuned = modeDef.tune(Z(prev[rKey], prev[xKey]));
            return { ...prev, ...tuned };
          });
        }
      }, [modeDef]);

      // Auto-tune on initial load if no URL parameters provided
      useEffect(() => {
        if (!didAutoTune.current && !window.location.search && modeDef.hasAutoTune) {
          didAutoTune.current = true;
          handleAutoTune();
        }
      }, [handleAutoTune, modeDef]);

      const handlePreset = (preset) => {
        const { r, x, label, heightFraction, ...extra } = preset;
        const { r: rKey, x: xKey } = modeDef.impedanceKeys;

        if (heightFraction != null) {
          // Computed preset — requires freq (button is disabled without it)
          const freq = parseFloat(p.freqMHz);
          if (!freq || freq <= 0) return;
          const lambda = C_SPEED / (freq * 1e6);
          const heightM = (heightFraction * lambda).toFixed(1);
          const diam = parseFloat(p.elementDiamMm) > 0 ? p.elementDiamMm : '2';
          const groundType = extra.groundType || 'average';
          const computed = calcDipoleOverGround(freq, parseFloat(heightM), parseFloat(diam), groundType);
          if (!computed) return;
          const updates = {
            [rKey]: Math.round(computed.r), [xKey]: Math.round(computed.x),
            _appliedCalcR: computed.r, _appliedCalcX: computed.x,
            heightM, elementDiamMm: diam, calcOpen: Math.abs(p.calcOpen || 0) + 1, ...extra,
          };
          if (modeDef.tune) Object.assign(updates, modeDef.tune(Z(computed.r, computed.x)));
          set(updates);
        } else {
          const updates = { [rKey]: r, [xKey]: x, calcOpen: -Math.abs(p.calcOpen || 0) - 1, ...extra };
          if (modeDef.tune) Object.assign(updates, modeDef.tune(Z(r, x)));
          set(updates);
        }
      };

      const isPresetActive = (preset) => {
        const { r: rKey, x: xKey } = modeDef.impedanceKeys;
        if ('heightFraction' in preset) {
          if (p.groundType !== preset.groundType) return false;
          const freq = parseFloat(p.freqMHz);
          if (!freq || freq <= 0) return false;
          const expectedHeight = (preset.heightFraction * C_SPEED / (freq * 1e6)).toFixed(1);
          return parseFloat(p.heightM).toFixed(1) === expectedHeight;
        }
        if (p[rKey] !== preset.r || p[xKey] !== preset.x) return false;
        if ('groundType' in preset && p.groundType !== preset.groundType) return false;
        if ('feedOffset' in preset) return p.feedOffset === preset.feedOffset;
        return true;
      };

      /** Apply computed dipole impedance to the mode's R/X sliders + auto-tune */
      const handleApplyCalculatedZ = (computedZ) => {
        const { r: rKey, x: xKey } = modeDef.impedanceKeys;
        const updates = {
          [rKey]: Math.round(computedZ.r), [xKey]: Math.round(computedZ.x),
          _appliedCalcR: computedZ.r, _appliedCalcX: computedZ.x,
        };
        if (modeDef.tune) Object.assign(updates, modeDef.tune(computedZ));
        set(updates);
      };

      return (
        <div className="app">
          {mode === 'ocfd' && <div className="experimental-banner">Experimental</div>}
          {/* Mode Toggle */}
          <div className="mode-toggle">
            {Object.entries(MODE_MAP).map(([modeKey, def]) => (
              <button
                key={modeKey}
                className={`btn mode-btn ${mode === modeKey ? def.activeClass : ''}`}
                onClick={() => set({ mode: modeKey, calcOpen: 0, _appliedCalcR: undefined, _appliedCalcX: undefined })}
              >
                {def.buttonLabel}
              </button>
            ))}
          </div>

          <h1 className="title">{modeDef.title}</h1>
          <div className="footer" style={{ marginTop: '-12px' }}>By AI6KG &lt;<a href="mailto:ai6kg@arrl.net">ai6kg@arrl.net</a>&gt;</div>

          {/* Presets */}
          <div className="presets">
            {modeDef.presets.map((preset) => {
              const needsFreq = preset.heightFraction != null;
              const freqOk = parseFloat(p.freqMHz) > 0;
              return (
                <button
                  key={preset.label}
                  className={`btn preset-btn ${isPresetActive(preset) ? 'active' : ''}`}
                  onClick={() => handlePreset(preset)}
                  disabled={needsFreq && !freqOk}
                  style={needsFreq && !freqOk ? { opacity: 0.4 } : undefined}
                  data-tooltip={needsFreq && !freqOk ? 'Enter frequency first' : undefined}
                >
                  {preset.label}
                </button>
              );
            })}
          </div>

          {/* Physical Parameters */}
          <div className="physical-params">
            <label>
              Freq (MHz):
              <input
                type="number"
                value={freqMHz}
                onChange={setStr('freqMHz')}
                min="1"
                max="3000"
                step="0.1"
              />
            </label>
            <span style={{ color: '#555', alignSelf: 'center', minWidth: '90px' }}>
              {physical ? `\u03BB = ${(physical.lambdaMm / 1000).toFixed(2)}m` : ''}
            </span>
            {modeDef.hasAutoTune && (
              <button
                className={`btn auto-tune-btn ${mode}`}
                onClick={handleAutoTune}
                style={{ alignSelf: 'center' }}
                data-tooltip="Find optimal match parameters"
              >
                Auto-Tune
              </button>
            )}
            <button
              className="btn preset-btn"
              onClick={() => { if (navigator.clipboard) navigator.clipboard.writeText(window.location.href); }}
              style={{ alignSelf: 'center' }}
              data-tooltip="Copy shareable link to clipboard"
            >
              Copy URL
            </button>
            <button
              className="btn preset-btn"
              onClick={() => set({ ...DEFAULTS, mode: p.mode })}
              style={{ alignSelf: 'center' }}
              data-tooltip="Reset all parameters to defaults"
            >
              Reset
            </button>
          </div>

          <div className="main-content">
            {/* Smith Chart */}
            <svg width={SIZE} height={SIZE} viewBox={`0 0 ${SIZE} ${SIZE}`} className="smith-chart">
              {/* Outer circle */}
              <circle cx={CX} cy={CY} r={RADIUS} fill="none" stroke={COLORS.gridOuter} strokeWidth="2" />

              {/* Resistance circles */}
              {rCircles.map(({ r, cx, radius }) => (
                <circle key={`r-${r}`} cx={cx} cy={CY} r={radius} fill="none" stroke={COLORS.grid} strokeWidth="1" />
              ))}

              {/* Reactance arcs */}
              {xArcs.map(({ x, cx, cy, radius }) => {
                const pts = createXArc(x, cx, cy, radius);
                if (pts.length < 2) return null;
                return <path key={`x-${x}`} d={pointsToPath(pts)} fill="none" stroke={COLORS.grid} strokeWidth="1" />;
              })}

              {/* Center line */}
              <line x1={CX - RADIUS} y1={CY} x2={CX + RADIUS} y2={CY} stroke={COLORS.gridCenter} strokeWidth="1" />

              {/* Labels */}
              <text x={CX - RADIUS - 8} y={CY + 4} fill={COLORS.label} fontSize="10" textAnchor="end">0</text>
              <text x={CX + RADIUS + 8} y={CY + 4} fill={COLORS.label} fontSize="10" textAnchor="start">{'\u221E'}</text>
              <text x={CX} y={CY - 8} fill={COLORS.label} fontSize="9" textAnchor="middle">50{'\u03A9'}</text>
              <text x={CX} y={CY - RADIUS - 8} fill={COLORS.label} fontSize="9" textAnchor="middle">+jX</text>
              <text x={CX} y={CY + RADIUS + 16} fill={COLORS.label} fontSize="9" textAnchor="middle">{'\u2212'}jX</text>

              {/* Mode-specific overlay */}
              <modeDef.SmithOverlay result={result} state={p} />

              {/* Target impedance */}
              {(() => {
                const targetZ0 = mode === MODES.OCFD ? p.feedlineZ0 : Z0;
                const pt = zToScreen(Z(targetZ0, 0));
                return (
                  <>
                    <circle cx={pt.x} cy={pt.y} r="6" fill="none" stroke={COLORS.hairpin} strokeWidth="2" strokeDasharray="3,3" />
                    {targetZ0 !== Z0 && (
                      <text x={pt.x} y={pt.y - 10} fill={COLORS.label} fontSize="9" textAnchor="middle">
                        {targetZ0}{'\u03A9'}
                      </text>
                    )}
                  </>
                );
              })()}

              {/* Legend */}
              <g transform={`translate(${CX - RADIUS + 10}, ${CY + RADIUS - 80})`}>
                <modeDef.Legend />
              </g>
            </svg>

            {/* Controls */}
            <div className="controls">
              <modeDef.Controls state={p} result={result} physical={physical}
                setNum={setNum} set={set} setStr={setStr}
                onApplyZ={handleApplyCalculatedZ} />
            </div>
          </div>

          {/* Physical diagram */}
          <div className="diagram-container">
            <div className="diagram-title">{modeDef.diagramTitle}</div>
            <modeDef.Diagram state={p} physical={physical} />
          </div>

          {/* Info */}
          <modeDef.Info />

          {/* Footer */}
          <div className="footer">
            {'\u00A9'} 2025-2026 Christopher Hoover. <a href="https://github.com/charlieh0tel/ham_radio/blob/master/LICENSE">MIT License</a>.{' '}
            <a href="https://github.com/charlieh0tel/ham_radio">GitHub</a>.{' '}
            <a href="https://github.com/charlieh0tel/ham_radio/issues">Bugs &amp; Feedback</a>
          </div>
        </div>
      );
    }

    ReactDOM.createRoot(document.getElementById('root')).render(<AntennaMatching />);
  </script>
</body>
</html>
