<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Antenna Impedance Matching - Smith Chart</title>
  <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script src="https://unpkg.com/mathjs@12/lib/browser/math.js"></script>
  <script src="https://unpkg.com/fmin@0.0.2/build/fmin.min.js"></script>
  <style>
    body { margin: 0; }

    /* Layout */
    .app {
      min-height: 100vh;
      background: #0a0a0a;
      color: #e0e0e0;
      font-family: "JetBrains Mono", "SF Mono", Monaco, Consolas, monospace;
      padding: 24px;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 20px;
    }

    .main-content {
      display: flex;
      gap: 32px;
      flex-wrap: wrap;
      justify-content: center;
    }

    /* Buttons - Base */
    .btn {
      border: none;
      border-radius: 6px;
      cursor: pointer;
      font-family: inherit;
      font-weight: 600;
      transition: all 0.2s;
    }

    /* Mode Toggle */
    .mode-toggle {
      display: flex;
      gap: 8px;
      background: #1a1a1a;
      padding: 6px;
      border-radius: 8px;
    }

    .mode-btn {
      padding: 14px 28px;
      background: transparent;
      color: #888;
      font-size: 16px;
    }

    .mode-btn.active-gamma {
      background: #da77f2;
      color: #000;
    }

    .mode-btn.active-hairpin {
      background: #00ff88;
      color: #000;
    }

    .mode-btn.active-ocfd {
      background: #ffd43b;
      color: #000;
    }

    /* Title */
    .title {
      font-size: 26px;
      font-weight: 500;
      letter-spacing: 0.05em;
      color: #fff;
      margin: 0;
      text-transform: uppercase;
    }

    /* Presets */
    .presets {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
      justify-content: center;
    }

    .preset-btn {
      padding: 10px 18px;
      background: #1a1a1a;
      color: #888;
      border: 1px solid #333;
      font-size: 14px;
      font-weight: 400;
    }

    .preset-btn.active {
      background: #333;
      color: #fff;
    }

    .auto-tune-btn {
      padding: 10px 26px;
      color: #000;
      font-size: 14px;
    }

    .auto-tune-btn.gamma { background: #da77f2; }
    .auto-tune-btn.hairpin { background: #00ff88; }
    .auto-tune-btn.ocfd { background: #ffd43b; }

    /* Smith Chart */
    .smith-chart {
      background: #111;
      border-radius: 8px;
      flex-shrink: 0;
      aspect-ratio: 1;
    }

    /* Controls */
    .controls {
      display: flex;
      flex-direction: column;
      gap: 12px;
      min-width: 420px;
    }

    .control-panel {
      background: #1a1a1a;
      padding: 18px;
      border-radius: 8px;
      border: 1px solid #333;
    }

    .control-header {
      font-size: 14px;
      margin-bottom: 12px;
      font-weight: 600;
    }

    .control-label {
      display: block;
      margin-bottom: 8px;
    }

    .control-label:last-of-type {
      margin-bottom: 0;
    }

    .control-text {
      font-size: 15px;
      color: #888;
    }

    .control-slider {
      width: 100%;
      margin-top: 4px;
    }

    .control-result {
      font-size: 14px;
      color: #aaa;
      margin-top: 6px;
    }

    .control-hint {
      font-size: 13px;
      color: #666;
      margin-top: 2px;
    }

    .impedance-display {
      margin-top: 8px;
      font-size: 17px;
      color: #fff;
      font-weight: 500;
    }

    /* Result Panel */
    .result-panel {
      padding: 18px;
      border-radius: 8px;
      border-width: 2px;
      border-style: solid;
    }

    .result-panel.good { background: #0a1a0a; border-color: #00ff88; }
    .result-panel.normal { background: #1a1a1a; }

    .result-z {
      font-size: 22px;
      color: #fff;
      margin-bottom: 6px;
      font-weight: 600;
    }

    .result-swr {
      font-size: 20px;
      font-weight: 600;
    }

    .swr-excellent { color: #00ff88; }
    .swr-good { color: #4ade80; }
    .swr-ok { color: #ffd43b; }
    .swr-poor { color: #ff6b6b; }

    .swr-table {
      display: flex;
      flex-direction: column;
      gap: 4px;
      margin-top: 6px;
    }

    .swr-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-size: 16px;
    }

    .swr-row-label {
      color: #888;
      font-size: 15px;
    }

    .swr-row-value {
      font-weight: 600;
    }

    .feedline-selector {
      display: flex;
      gap: 6px;
    }

    .swr-row-best {
      background: rgba(255, 255, 255, 0.05);
      padding: 2px 6px;
      border-radius: 4px;
    }

    /* Physical Diagram */
    .diagram-container {
      background: #111;
      padding: 20px;
      border-radius: 8px;
      max-width: 900px;
      width: 100%;
    }

    .diagram-title {
      color: #888;
      font-size: 14px;
      margin-bottom: 12px;
      text-align: center;
      font-weight: 600;
    }

    .diagram-svg {
      display: block;
      width: 100%;
    }

    /* Info */
    .info {
      max-width: 900px;
      font-size: 15px;
      color: #666;
      line-height: 1.6;
      text-align: center;
    }

    .info strong {
      color: #aaa;
    }

    /* Footer */
    .footer {
      font-size: 14px;
      color: #555;
      text-align: center;
      margin-top: 12px;
    }

    .footer a {
      color: #888;
    }

    /* Physical params */
    .physical-params {
      display: flex;
      gap: 16px;
      font-size: 14px;
      color: #666;
    }

    .physical-params label {
      display: flex;
      align-items: center;
      gap: 4px;
    }

    .physical-params input {
      width: 80px;
      padding: 6px 8px;
      background: #1a1a1a;
      border: 1px solid #333;
      border-radius: 4px;
      color: #aaa;
      font-family: inherit;
      font-size: 14px;
    }

    .physical-params input:focus {
      outline: none;
      border-color: #555;
    }

    .physical-hint {
      font-size: 13px;
      color: #888;
      margin-top: 4px;
    }

    /* Mobile responsive */
    @media (max-width: 800px) {
      .app {
        padding: 16px;
        gap: 16px;
      }

      .main-content {
        flex-direction: column;
        align-items: center;
      }

      .smith-chart {
        width: 100%;
        max-width: 400px;
        height: auto;
        aspect-ratio: 1;
      }

      .controls {
        min-width: unset;
        width: 100%;
        max-width: 400px;
      }

      .physical-params {
        flex-wrap: wrap;
        justify-content: center;
      }

      .mode-toggle {
        flex-wrap: wrap;
        justify-content: center;
      }

      .presets {
        justify-content: center;
      }

      .diagram-container {
        max-width: 100%;
      }
    }

    /* Tooltips */
    [data-tooltip] {
      position: relative;
    }

    [data-tooltip]:hover::after {
      content: attr(data-tooltip);
      position: absolute;
      bottom: 100%;
      left: 50%;
      transform: translateX(-50%);
      background: #333;
      color: #fff;
      padding: 6px 10px;
      border-radius: 4px;
      font-size: 11px;
      white-space: nowrap;
      z-index: 100;
      margin-bottom: 4px;
    }

    /* Print styles */
    @media print {
      .app {
        background: white;
        color: black;
        padding: 0;
      }

      .mode-toggle,
      .presets,
      .physical-params,
      input[type="range"],
      .footer a {
        display: none;
      }

      .control-panel,
      .result-panel {
        background: white;
        border: 1px solid #999;
        break-inside: avoid;
      }

      .control-header,
      .control-text,
      .control-result,
      .control-hint,
      .physical-hint,
      .diagram-title,
      .info,
      .info strong,
      .title {
        color: black;
      }

      .smith-chart,
      .diagram-container {
        background: white;
      }

      .footer {
        color: #666;
      }
    }
  </style>
</head>
<body>
  <div id="root"></div>
  <script type="text/babel">
    const { useState, useMemo, useCallback, useEffect, useRef } = React;
    const { complex, add, subtract, multiply, divide } = math;

    // ============================================================
    // JSDoc Type Definitions
    // ============================================================

    /**
     * @typedef {Object} Impedance
     * @property {number} r - Resistance in ohms
     * @property {number} x - Reactance in ohms (positive = inductive, negative = capacitive)
     */

    /**
     * @typedef {Object} ReflectionCoefficient
     * @property {number} re - Real part of gamma
     * @property {number} im - Imaginary part of gamma
     */

    /**
     * @typedef {Object} ScreenPoint
     * @property {number} x - X coordinate on screen
     * @property {number} y - Y coordinate on screen
     */

    /**
     * @typedef {Object} GammaMatchResult
     * @property {ScreenPoint} origPt - Original impedance point
     * @property {ScreenPoint} afterTapPt - Point after tap ratio transformation
     * @property {ScreenPoint} afterShuntPt - Point after shunt inductance
     * @property {ScreenPoint} finalPt - Final matched impedance point
     * @property {Impedance} afterTap - Impedance after tap ratio
     * @property {Impedance} afterShunt - Impedance after shunt inductance
     * @property {Impedance} finalZ - Final matched impedance
     * @property {ScreenPoint[]} tapPath - Path for tap ratio transformation
     * @property {ScreenPoint[]} shuntPath - Path for shunt inductance
     * @property {ScreenPoint[]} seriesPath - Path for series capacitor
     * @property {number} swr - Standing wave ratio
     */

    /**
     * @typedef {Object} HairpinMatchResult
     * @property {ScreenPoint} origPt - Original impedance point
     * @property {ScreenPoint} shortenedPt - Point after shortening
     * @property {ScreenPoint} finalPt - Final matched impedance point
     * @property {Impedance} afterShorten - Impedance after shortening
     * @property {Impedance} finalZ - Final matched impedance
     * @property {ScreenPoint[]} shortenPath - Path for shortening transformation
     * @property {ScreenPoint[]} hpPath - Path for hairpin inductance
     * @property {number} swr - Standing wave ratio
     */

    /**
     * @typedef {Object} SmithChartGeometry
     * @property {function(number, number): ScreenPoint} zToScreen - Convert impedance to screen coordinates
     * @property {Array<{r: number, cx: number, radius: number}>} rCircles - Constant resistance circles
     * @property {Array<{x: number, cx: number, cy: number, radius: number}>} xArcs - Constant reactance arcs
     * @property {function(number, number, number, number): ScreenPoint[]} createXArc - Create points for reactance arc
     */

    /**
     * @typedef {Object} Preset
     * @property {string} label - Display label
     * @property {number} r - Resistance value
     * @property {number} x - Reactance value
     */

    // ============================================================
    // Constants
    // ============================================================

    /** @type {number} Characteristic impedance */
    const Z0 = 50;

    /** @type {number} Smith chart size in pixels */
    const SIZE = 780;

    /** @type {number} Smith chart center X */
    const CX = SIZE / 2;

    /** @type {number} Smith chart center Y */
    const CY = SIZE / 2;

    /** @type {number} Smith chart radius */
    const RADIUS = SIZE / 2 - 45;

    /** @type {Object} Color palette */
    const COLORS = Object.freeze({
      orig: '#ff6b6b',
      step1: '#ffa94d',
      step2: '#da77f2',
      step3: '#66d9e8',
      final: '#4dabf7',
      hairpin: '#00ff88',
      ocfd: '#ffd43b',
      coax: '#4dabf7',
      // Grid colors (dark to light)
      grid: '#444',
      gridOuter: '#555',
      gridCenter: '#666',
      label: '#888',
      element: '#666',
      wire: '#888'
    });

    /** @type {number[]} Feedline impedances for OCFD SWR calculations */
    const FEEDLINE_IMPEDANCES = Object.freeze([50, 300, 450]);

    /** @type {Preset[]} Gamma match antenna presets */
    const GAMMA_PRESETS = Object.freeze([
      { label: 'Dipole (73+j43Ω)', r: 73, x: 43 },
      { label: 'Yagi (25Ω)', r: 25, x: 0 },
      { label: 'Low-Z Yagi (18−j10Ω)', r: 18, x: -10 },
    ]);

    /** @type {Preset[]} Hairpin match antenna presets */
    const HAIRPIN_PRESETS = Object.freeze([
      { label: 'Yagi (25Ω)', r: 25, x: 0 },
      { label: 'Low-Z Yagi (18−j10Ω)', r: 18, x: -10 },
      { label: 'Dipole (73Ω)', r: 73, x: 0 },
    ]);

    /** @type {Preset[]} OCFD center impedance presets (includes feedOffset) */
    const OCFD_PRESETS = Object.freeze([
      { label: 'Free-Space λ/2 (73+j43Ω)', r: 73, x: 43, feedOffset: 33 },
      { label: 'Low Height (~λ/4 AGL)', r: 55, x: 0, feedOffset: 33 },
    ]);

    /** @type {number[]} Normalized resistance values for Smith chart circles */
    const R_VALUES = Object.freeze([0, 0.2, 0.5, 1, 2, 5]);

    /** @type {number[]} Normalized reactance values for Smith chart arcs */
    const X_VALUES = Object.freeze([0.2, 0.5, 1, 2, 5]);

    /** @type {number} Speed of light in m/s */
    const C_SPEED = 299792458;

    /** @type {number} Number of points for path generation */
    const PATH_STEPS = 50;

    /** Max resistance for path clipping */
    const PATH_R_MAX = 1000;

    /** Threshold below which shunt reactance is treated as zero (open circuit) */
    const SHUNT_X_MIN = 0.1;

    /** Maximum displayable SWR (returned when reflection coefficient >= 1) */
    const SWR_MAX = 99;

    /** @type {Object} SWR thresholds for color coding */
    const SWR_THRESHOLDS = Object.freeze({
      excellent: 1.2,
      good: 1.5,
      ok: 2.0
    });

    /** @type {Object} Match mode constants */
    const MODES = Object.freeze({
      GAMMA: 'gamma',
      HAIRPIN: 'hairpin',
      OCFD: 'ocfd'
    });

    /** @type {Object} URL parameter keys */
    const URL_KEYS = Object.freeze({
      mode: 'mode',
      antR: 'r',
      antX: 'x',
      tapRatio: 'tap',
      gammaRodX: 'rod',
      seriesCapX: 'cap',
      shortening: 'short',
      hairpinX: 'hp',
      freqMHz: 'freq',
      elementDiamMm: 'diam',
      ocfdR: 'ocr',
      ocfdX: 'ocx',
      feedOffset: 'off',
      feedlineZ0: 'z0'
    });

    // ============================================================
    // Impedance Math Utilities
    // ============================================================

    /**
     * Create complex number from resistance and reactance.
     * Intentionally short name — used heavily in impedance math expressions
     * where verbosity would hurt readability.
     * @param {number} r - Resistance
     * @param {number} x - Reactance
     * @returns {Object} Complex number
     */
    const C = (r, x) => complex(r, x);

    /**
     * Create impedance object with formatting methods
     * @param {number} r - Resistance
     * @param {number} x - Reactance
     * @returns {Impedance}
     */
    const Z = (r, x) => ({
      r, x,
      format() { return `${this.r.toFixed(1)} ${this.x >= 0 ? '+' : '−'} j${Math.abs(this.x).toFixed(1)}`; },
      formatLabel() { return `${Math.round(this.r)}${this.x >= 0 ? '+' : ''}j${Math.round(this.x)}Ω`; }
    });

    /**
     * Convert complex number to impedance object
     * @param {Object} z - Complex number
     * @returns {Impedance}
     */
    const toRX = (z) => Z(z.re, z.im);

    /**
     * Convert impedance to reflection coefficient: Γ = (z - 1) / (z + 1)
     * @param {Impedance} z - Impedance
     * @returns {ReflectionCoefficient}
     */
    const zToGamma = (z) => {
      const zNorm = C(z.r / Z0, z.x / Z0);
      const gamma = divide(subtract(zNorm, 1), add(zNorm, 1));
      return { re: gamma.re, im: gamma.im };
    };

    /**
     * Apply tap ratio transformation: Z_new = Z × n²
     * @param {Impedance} z - Impedance
     * @param {number} ratio - Tap ratio (n)
     * @returns {Impedance}
     */
    const applyTapRatio = (z, ratio) => {
      const n2 = ratio * ratio;
      return Z(z.r * n2, z.x * n2);
    };

    /**
     * Add shunt reactance: Y_total = Y + Y_shunt, Z = 1/Y_total
     * @param {Impedance} z - Impedance
     * @param {number} xShunt - Shunt reactance value
     * @returns {Impedance}
     */
    const addShuntReactance = (z, xShunt) => {
      if (Math.abs(xShunt) < SHUNT_X_MIN) return z;
      const zc = C(z.r, z.x);
      const y = divide(1, zc);
      const yShunt = C(0, -1 / xShunt);
      const yTotal = add(y, yShunt);
      const zNew = divide(1, yTotal);
      return toRX(zNew);
    };

    /**
     * Add series reactance: Z_new = Z + jX_series
     * @param {Impedance} z - Impedance
     * @param {number} xSeries - Series reactance to add
     * @returns {Impedance}
     */
    const addSeriesReactance = (z, xSeries) => Z(z.r, z.x + xSeries);

    /**
     * Calculate SWR from impedance (relative to Z0=50Ω)
     * @param {Impedance} z - Impedance
     * @returns {number} SWR value
     */
    const calcSWR = (z) => {
      const gamma = zToGamma(z);
      const gammaMag = Math.sqrt(gamma.re ** 2 + gamma.im ** 2);
      if (gammaMag >= 1) return SWR_MAX;
      return (1 + gammaMag) / (1 - gammaMag);
    };

    /**
     * Calculate SWR for arbitrary feedline impedance Z₀
     * Γ = (Z_feed − Z₀) / (Z_feed + Z₀), SWR = (1+|Γ|) / (1−|Γ|)
     * @param {Impedance} z - Feed impedance
     * @param {number} z0 - Feedline characteristic impedance
     * @returns {number} SWR value
     */
    const calcSWRForZ0 = (z, z0) => {
      const zc = C(z.r, z.x);
      const gamma = divide(subtract(zc, z0), add(zc, z0));
      const gammaMag = Math.sqrt(gamma.re ** 2 + gamma.im ** 2);
      if (gammaMag >= 1) return SWR_MAX;
      return (1 + gammaMag) / (1 - gammaMag);
    };

    // ============================================================
    // SVG Path Utilities
    // ============================================================

    /**
     * Convert array of points to SVG path string
     * @param {ScreenPoint[]} points
     * @returns {string}
     */
    const pointsToPath = (points) =>
      points.map((p, i) => `${i === 0 ? 'M' : 'L'} ${p.x} ${p.y}`).join(' ');

    /**
     * Calculate shunt arc path and arrow angle along constant-G circle
     * @param {Impedance} z - Starting impedance
     * @param {number} shuntX - Shunt reactance to add
     * @param {function} zToScreen - Impedance to screen coordinate converter
     * @returns {{startPt: ScreenPoint, endPt: ScreenPoint, endZ: Impedance, arcPath: string, arrowAngle: number}}
     */
    const calcShuntArc = (z, shuntX, zToScreen) => {
      const startPt = zToScreen(z);
      const endZ = addShuntReactance(z, shuntX);
      const endPt = zToScreen(endZ);

      // Normalized conductance g = G * Z0 = Z0 * R / (R² + X²)
      const g = Z0 * z.r / (z.r ** 2 + z.x ** 2);

      // Constant-G circle: center at (-g/(g+1), 0) in Gamma, radius 1/(g+1)
      const circleRadius = RADIUS / (g + 1);
      const circleCx = CX - (g / (g + 1)) * RADIUS;
      const circleCy = CY;

      // Vectors from circle center to start and end
      const v1x = startPt.x - circleCx, v1y = startPt.y - circleCy;
      const v2x = endPt.x - circleCx, v2y = endPt.y - circleCy;

      // Cross product determines sweep direction (positive = counter-clockwise)
      const cross = v1x * v2y - v1y * v2x;
      const sweepFlag = cross > 0 ? 1 : 0;

      // SVG arc path (large-arc-flag = 0 for minor arc)
      const arcPath = `M ${startPt.x} ${startPt.y} A ${circleRadius} ${circleRadius} 0 0 ${sweepFlag} ${endPt.x} ${endPt.y}`;

      // Arrow angle: tangent to circle at endpoint
      // Tangent is perpendicular to radius; direction depends on sweep
      const radialAngle = Math.atan2(endPt.y - circleCy, endPt.x - circleCx);
      const arrowAngle = (radialAngle + (sweepFlag ? Math.PI / 2 : -Math.PI / 2)) * 180 / Math.PI;

      return { startPt, endPt, endZ, arcPath, arrowAngle };
    };

    // ============================================================
    // Custom Hooks
    // ============================================================

    /**
     * Hook for Smith chart geometry calculations
     * @returns {SmithChartGeometry}
     */
    const useSmithChart = () => {
      return useMemo(() => {
        /**
         * Convert reflection coefficient to screen coordinates
         * @param {ReflectionCoefficient} gamma
         * @returns {ScreenPoint}
         */
        const gammaToScreen = (gamma) => ({
          x: CX + gamma.re * RADIUS,
          y: CY - gamma.im * RADIUS
        });

        /**
         * Convert impedance to screen coordinates
         * @param {Impedance} z - Impedance
         * @returns {ScreenPoint}
         */
        const zToScreen = (z) => gammaToScreen(zToGamma(z));

        /** Constant resistance circles */
        const rCircles = R_VALUES.map(r => ({
          r,
          cx: CX + (r / (r + 1)) * RADIUS,
          radius: RADIUS / (r + 1)
        }));

        /** Constant reactance arcs */
        const xArcs = X_VALUES.flatMap(x => [x, -x]).map(x => ({
          x,
          cx: CX + RADIUS,
          cy: CY - RADIUS / x,
          radius: Math.abs(RADIUS / x)
        }));

        /**
         * Create points for a reactance arc clipped to the Smith chart
         *
         * Constant-x arcs are circles with center at Γ = (1, 1/x) and radius 1/|x|.
         * They intersect the unit circle at (1, 0) and ((x²-1)/(1+x²), 2x/(1+x²)).
         *
         * @param {number} x - Normalized reactance value
         * @param {number} arcCx - Arc center X (screen coords)
         * @param {number} arcCy - Arc center Y (screen coords)
         * @param {number} arcRadius - Arc radius (screen coords)
         * @returns {ScreenPoint[]}
         */
        const createXArc = (x, arcCx, arcCy, arcRadius) => {
          const x2 = x * x;
          const denom = 1 + x2;

          // Exact intersection points on unit circle (screen coords)
          const p1x = CX + RADIUS;  // Infinity point (1, 0)
          const p1y = CY;
          const p2x = CX + (x2 - 1) / denom * RADIUS;
          const p2y = CY - 2 * x / denom * RADIUS;

          // Angles from arc center to each intersection
          const angle1 = Math.atan2(p1y - arcCy, p1x - arcCx);
          const angle2 = Math.atan2(p2y - arcCy, p2x - arcCx);

          // Determine sweep direction: we want to stay inside unit circle
          // Test midpoint of both possible paths
          const midAngleDirect = (angle1 + angle2) / 2;
          const midAngleAlt = midAngleDirect + (midAngleDirect > 0 ? -Math.PI : Math.PI);

          const testMid = (angle) => {
            const gx = (arcCx + arcRadius * Math.cos(angle) - CX) / RADIUS;
            const gy = (CY - (arcCy + arcRadius * Math.sin(angle))) / RADIUS;
            return gx * gx + gy * gy;
          };

          // Choose path where midpoint is inside unit circle (|Γ|² < 1)
          const goLongWay = testMid(midAngleDirect) > testMid(midAngleAlt);
          const endAngle = goLongWay
            ? angle2 + (angle2 > angle1 ? -2 : 2) * Math.PI
            : angle2;

          // Generate arc points
          const points = [{ x: p1x, y: p1y }];  // Start exactly at infinity point
          for (let i = 1; i < PATH_STEPS; i++) {
            const angle = angle1 + (endAngle - angle1) * i / PATH_STEPS;
            points.push({
              x: arcCx + arcRadius * Math.cos(angle),
              y: arcCy + arcRadius * Math.sin(angle)
            });
          }
          points.push({ x: p2x, y: p2y });  // End exactly at intersection
          return points;
        };

        return { zToScreen, rCircles, xArcs, createXArc };
      }, []);
    };

    // ============================================================
    // Sub-Components
    // ============================================================

    /**
     * Arrow head component for path endpoints
     * @param {Object} props
     * @param {number} props.x - X position
     * @param {number} props.y - Y position
     * @param {number} props.angle - Rotation angle in degrees
     * @param {string} props.color - Fill color
     */
    const ArrowHead = ({ x, y, angle, color }) => (
      <polygon
        points="-7,-4 0,0 -7,4"
        fill={color}
        transform={`translate(${x}, ${y}) rotate(${angle})`}
      />
    );

    /**
     * Calculate arrow angle from path
     * @param {ScreenPoint[]} path - Array of points
     * @param {ScreenPoint} endPt - End point
     * @param {number} [offset=5] - Offset from end for angle calculation
     * @returns {number} Angle in degrees
     */
    const getArrowAngle = (path, endPt, offset = 5) => {
      if (path.length <= offset) return 0;
      const prev = path[path.length - offset];
      return Math.atan2(endPt.y - prev.y, endPt.x - prev.x) * 180 / Math.PI;
    };

    /**
     * Control panel wrapper component
     * @param {Object} props
     * @param {string} props.color - Border and header color
     * @param {string} props.title - Panel header text
     * @param {string} [props.tooltip] - Tooltip text
     * @param {React.ReactNode} props.children - Panel content
     */
    const ControlPanel = ({ color, title, tooltip, children }) => (
      <div className="control-panel" style={{ borderColor: color }} data-tooltip={tooltip}>
        <div className="control-header" style={{ color }}>{title}</div>
        {children}
      </div>
    );

    // ============================================================
    // Per-Mode Definitions
    // ============================================================

    /** Gamma match mode — all mode-specific behavior in one object */
    const gammaMode = {
      key: 'gamma',
      title: 'Gamma Match',
      buttonLabel: 'Gamma Match',
      activeClass: 'active-gamma',
      diagramTitle: 'GAMMA MATCH PHYSICAL ARRANGEMENT',
      hasAutoTune: true,
      showElementDiam: false,
      presets: GAMMA_PRESETS,
      impedanceKeys: { r: 'antR', x: 'antX' },

      serializeUrl(p) {
        return {
          [URL_KEYS.antR]: Math.round(p.antR),
          [URL_KEYS.antX]: Math.round(p.antX),
          [URL_KEYS.tapRatio]: p.tapRatio.toFixed(2),
          [URL_KEYS.gammaRodX]: Math.round(p.gammaRodX),
          [URL_KEYS.seriesCapX]: Math.round(p.seriesCapX),
        };
      },

      tune(z) {
        const bounds = {
          tap: { min: 1, max: 2.5 },
          rod: { min: 20, max: 400 },
          cap: { min: 0, max: 100 }
        };
        const { tap: t, rod: rd, cap: c } = bounds;
        const result = fmin.nelderMead(([tap, rod, cap]) => {
          if (tap < t.min || tap > t.max || rod < rd.min || rod > rd.max || cap < c.min || cap > c.max) {
            return SWR_MAX;
          }
          const z1 = applyTapRatio(z, tap);
          const z2 = addShuntReactance(z1, rod);
          const z3 = addSeriesReactance(z2, -cap);
          return calcSWR(z3);
        }, [(t.min + t.max) / 2, (rd.min + rd.max) / 2, (c.min + c.max) / 2]);
        return {
          tapRatio: Math.round(result.x[0] * 100) / 100,
          gammaRodX: Math.round(result.x[1]),
          seriesCapX: Math.round(result.x[2])
        };
      },

      calc(p, zToScreen) {
        const antZ = Z(p.antR, p.antX);
        // Tap ratio path
        const tapPath = [];
        for (let i = 0; i <= PATH_STEPS; i++) {
          const ratio = 1 + (p.tapRatio - 1) * (i / PATH_STEPS);
          const z = applyTapRatio(antZ, ratio);
          if (z.r > 0 && z.r < PATH_R_MAX) {
            tapPath.push(zToScreen(z));
          }
        }
        const afterTap = applyTapRatio(antZ, p.tapRatio);
        // Shunt inductance arc along constant-G circle
        const shuntArc = calcShuntArc(afterTap, p.gammaRodX, zToScreen);
        // Series capacitor path
        const seriesPath = [];
        for (let i = 0; i <= PATH_STEPS; i++) {
          const xC = -p.seriesCapX * (i / PATH_STEPS);
          const z = addSeriesReactance(shuntArc.endZ, xC);
          seriesPath.push(zToScreen(z));
        }
        const finalZ = addSeriesReactance(shuntArc.endZ, -p.seriesCapX);
        return {
          origPt: zToScreen(antZ),
          afterTapPt: zToScreen(afterTap),
          afterShuntPt: shuntArc.endPt,
          finalPt: zToScreen(finalZ),
          afterTap,
          afterShunt: shuntArc.endZ,
          finalZ,
          tapPath,
          shuntArc,
          seriesPath,
          swr: calcSWR(finalZ)
        };
      },

      physical(p, base) {
        const capPf = p.seriesCapX > 0
          ? 1e12 / (2 * Math.PI * parseFloat(p.freqMHz) * 1e6 * p.seriesCapX)
          : null;
        const tapDistMm = (base.lambdaMm / (2 * Math.PI)) * Math.acos(1 / p.tapRatio);
        return { capPf, tapDistMm };
      },

      SmithOverlay: ({ result, state }) => (
        <>
          {/* Tap ratio path */}
          {result.tapPath.length > 1 && (
            <path
              d={pointsToPath(result.tapPath)}
              fill="none" stroke={COLORS.step1} strokeWidth="3" strokeDasharray="6,4" strokeLinecap="round"
            />
          )}
          {/* Shunt inductance path - true arc */}
          <path
            d={result.shuntArc.arcPath}
            fill="none" stroke={COLORS.step2} strokeWidth="3" strokeLinecap="round"
          />
          {/* Series capacitor path */}
          {result.seriesPath.length > 1 && (
            <path
              d={pointsToPath(result.seriesPath)}
              fill="none" stroke={COLORS.step3} strokeWidth="3" strokeLinecap="round"
            />
          )}
          {/* Arrows */}
          {result.tapPath.length > 3 && (
            <ArrowHead x={result.afterTapPt.x} y={result.afterTapPt.y}
              angle={getArrowAngle(result.tapPath, result.afterTapPt)} color={COLORS.step1} />
          )}
          <ArrowHead x={result.afterShuntPt.x} y={result.afterShuntPt.y}
            angle={result.shuntArc.arrowAngle} color={COLORS.step2} />
          {result.seriesPath.length > 3 && (
            <ArrowHead x={result.finalPt.x} y={result.finalPt.y}
              angle={getArrowAngle(result.seriesPath, result.finalPt)} color={COLORS.step3} />
          )}
          {/* Points */}
          <circle cx={result.origPt.x} cy={result.origPt.y} r="10" fill={COLORS.orig} stroke="#fff" strokeWidth="2" />
          <text x={result.origPt.x - 14} y={result.origPt.y - 14}
            fill={COLORS.orig} fontSize="11" fontWeight="600" textAnchor="end">
            {'\u2460'} {Z(state.antR, state.antX).formatLabel()}
          </text>
          <circle cx={result.afterTapPt.x} cy={result.afterTapPt.y} r="7" fill={COLORS.step1} stroke="#fff" strokeWidth="2" />
          <text x={result.afterTapPt.x + 12} y={result.afterTapPt.y - 8}
            fill={COLORS.step1} fontSize="10" fontWeight="600">
            {'\u2461'} {result.afterTap.formatLabel()}
          </text>
          <circle cx={result.afterShuntPt.x} cy={result.afterShuntPt.y} r="7" fill={COLORS.step2} stroke="#fff" strokeWidth="2" />
          <text x={result.afterShuntPt.x + 12} y={result.afterShuntPt.y - 8}
            fill={COLORS.step2} fontSize="10" fontWeight="600">
            {'\u2462'} {result.afterShunt.formatLabel()}
          </text>
          <circle cx={result.finalPt.x} cy={result.finalPt.y} r="10" fill={COLORS.final} stroke="#fff" strokeWidth="2" />
          <text x={result.finalPt.x + 14} y={result.finalPt.y + 4} fill={COLORS.final} fontSize="11" fontWeight="600">
            {'\u2463'} {result.finalZ.formatLabel()}
          </text>
        </>
      ),

      Controls: ({ state, result, physical, setNum, freqMHz }) => (
        <>
          <ControlPanel color={COLORS.orig} title={'\u2460 ANTENNA IMPEDANCE'} tooltip="Starting impedance of the antenna feedpoint">
            <label className="control-label">
              <span className="control-text">Resistance: {state.antR}{'\u03A9'}</span>
              <input type="range" min="10" max="150" value={state.antR}
                onChange={setNum('antR')}
                aria-label="Antenna resistance"
                className="control-slider" style={{ accentColor: COLORS.orig }} />
            </label>
            <label className="control-label">
              <span className="control-text">
                Reactance: {state.antX >= 0 ? '+' : ''}j{state.antX}{'\u03A9'} {state.antX > 0 ? '(L)' : state.antX < 0 ? '(C)' : ''}
              </span>
              <input type="range" min="-100" max="100" value={state.antX}
                onChange={setNum('antX')}
                aria-label="Antenna reactance"
                className="control-slider" style={{ accentColor: COLORS.orig }} />
            </label>
            <div className="impedance-display">
              Z = {state.antR} {state.antX >= 0 ? '+' : '\u2212'} j{Math.abs(state.antX)} {'\u03A9'}
            </div>
          </ControlPanel>

          <ControlPanel color={COLORS.step1} title={'\u2461 AUTOTRANSFORMER (TAP RATIO)'} tooltip="Impedance step-up via tap position on driven element">
            <label className="control-label">
              <span className="control-text">n = {state.tapRatio.toFixed(2)} (Z {'\u00D7'} {(state.tapRatio * state.tapRatio).toFixed(2)})</span>
              <input type="range" min="1" max="2.5" step="0.01" value={state.tapRatio}
                onChange={setNum('tapRatio')}
                aria-label="Tap ratio"
                className="control-slider" style={{ accentColor: COLORS.step1 }} />
            </label>
            <div className="control-result">{'\u2192'} {result.afterTap.format()} {'\u03A9'}</div>
            {physical && (
              <div className="physical-hint">{'\u2248'} {Math.round(physical.tapDistMm)} mm from center</div>
            )}
          </ControlPanel>

          <ControlPanel color={COLORS.step2} title={'\u2462 GAMMA ROD (SHUNT +jX)'} tooltip="Parallel inductance from gamma rod coupling">
            <label className="control-label">
              <span className="control-text">Rod reactance: +j{state.gammaRodX}{'\u03A9'}</span>
              <input type="range" min="20" max="400" value={state.gammaRodX}
                onChange={setNum('gammaRodX')}
                aria-label="Gamma rod reactance"
                className="control-slider" style={{ accentColor: COLORS.step2 }} />
            </label>
            <div className="control-result">{'\u2192'} {result.afterShunt.format()} {'\u03A9'}</div>
          </ControlPanel>

          <ControlPanel color={COLORS.step3} title={'\u2463 SERIES CAPACITOR'} tooltip="Cancels inductive reactance to reach 50\u03A9">
            <label className="control-label">
              <span className="control-text">Cap reactance: {'\u2212'}j{state.seriesCapX}{'\u03A9'}</span>
              <input type="range" min="0" max="100" value={state.seriesCapX}
                onChange={setNum('seriesCapX')}
                aria-label="Series capacitor reactance"
                className="control-slider" style={{ accentColor: COLORS.step3 }} />
            </label>
            {physical && physical.capPf && (
              <div className="physical-hint">{'\u2248'} {Math.round(physical.capPf)} pF at {freqMHz} MHz</div>
            )}
          </ControlPanel>

          <div className={`result-panel ${result.swr < 1.5 ? 'good' : 'normal'}`}
            style={{ borderColor: result.swr < 1.5 ? COLORS.hairpin : COLORS.final }}
            aria-live="polite">
            <div className="control-header" style={{ color: COLORS.final }}>MATCHED IMPEDANCE</div>
            <div className="result-z">Z = {result.finalZ.format()} {'\u03A9'}</div>
            <div className={`result-swr ${getSWRClass(result.swr)}`}>
              SWR = {result.swr.toFixed(3)} : 1
            </div>
          </div>
        </>
      ),

      Diagram: () => (
        <svg viewBox="0 0 450 130" className="diagram-svg">
          {/* Driven element */}
          <line x1="50" y1="50" x2="400" y2="50" stroke={COLORS.element} strokeWidth="6" strokeLinecap="round" />
          <circle cx="225" cy="50" r="3" fill="#333" />
          <text x="225" y="35" fill={COLORS.element} fontSize="10" textAnchor="middle">Driven Element ≈ λ/2</text>
          {/* Gamma rod */}
          <line x1="225" y1="65" x2="310" y2="65" stroke={COLORS.step2} strokeWidth="4" strokeLinecap="round" />
          <text x="268" y="80" fill={COLORS.step2} fontSize="9" textAnchor="middle">Gamma Rod (+jX)</text>
          {/* Tap point connection */}
          <line x1="310" y1="50" x2="310" y2="65" stroke={COLORS.step1} strokeWidth="2" />
          <circle cx="310" cy="50" r="4" fill={COLORS.step1} />
          <text x="310" y="100" fill={COLORS.step1} fontSize="8" textAnchor="middle">tap point</text>
          {/* Series capacitor */}
          <line x1="225" y1="65" x2="183" y2="65" stroke={COLORS.wire} strokeWidth="2" />
          <line x1="183" y1="59" x2="183" y2="71" stroke={COLORS.step3} strokeWidth="2" />
          <line x1="177" y1="59" x2="177" y2="71" stroke={COLORS.step3} strokeWidth="2" />
          <line x1="177" y1="65" x2="150" y2="65" stroke={COLORS.wire} strokeWidth="2" />
          <text x="180" y="84" fill={COLORS.step3} fontSize="9" textAnchor="middle">C</text>
          {/* Feed lines to coax */}
          <line x1="225" y1="50" x2="225" y2="56" stroke={COLORS.wire} strokeWidth="2" />
          <line x1="225" y1="56" x2="150" y2="56" stroke={COLORS.wire} strokeWidth="2" />
          <line x1="150" y1="56" x2="150" y2="65" stroke={COLORS.coax} strokeWidth="3" />
          <line x1="150" y1="60" x2="100" y2="60" stroke={COLORS.coax} strokeWidth="3" />
          <text x="75" y="64" fill={COLORS.coax} fontSize="9" textAnchor="middle">50Ω</text>
        </svg>
      ),

      Legend: () => (
        <>
          <line x1="0" y1="0" x2="20" y2="0" stroke={COLORS.step1} strokeWidth="3" strokeDasharray="6,4" />
          <text x="26" y="4" fill={COLORS.step1} fontSize="9">{'\u2461'} Autotransformer</text>
          <line x1="0" y1="16" x2="20" y2="16" stroke={COLORS.step2} strokeWidth="3" />
          <text x="26" y="20" fill={COLORS.step2} fontSize="9">{'\u2462'} Shunt L</text>
          <line x1="0" y1="32" x2="20" y2="32" stroke={COLORS.step3} strokeWidth="3" />
          <text x="26" y="36" fill={COLORS.step3} fontSize="9">{'\u2463'} Series C</text>
        </>
      ),

      Info: () => (
        <div className="info">
          <strong>Gamma Match:</strong> Uses tap ratio to scale Z, shunt inductor (gamma rod), and series capacitor.
          Works for both high-Z and low-Z antennas by adjusting the tap position.
        </div>
      ),
    };

    /** Hairpin/beta match mode — all mode-specific behavior in one object */
    const hairpinMode = {
      key: 'hairpin',
      title: 'Beta (Hairpin) Match',
      buttonLabel: 'Beta (Hairpin) Match',
      activeClass: 'active-hairpin',
      diagramTitle: 'BETA (HAIRPIN) MATCH PHYSICAL ARRANGEMENT',
      hasAutoTune: true,
      showElementDiam: true,
      presets: HAIRPIN_PRESETS,
      impedanceKeys: { r: 'antR', x: 'antX' },

      serializeUrl(p) {
        return {
          [URL_KEYS.antR]: Math.round(p.antR),
          [URL_KEYS.antX]: Math.round(p.antX),
          [URL_KEYS.shortening]: Math.round(p.shortening),
          [URL_KEYS.hairpinX]: Math.round(p.hairpinX),
        };
      },

      tune(z) {
        const bounds = {
          shorten: { min: 0, max: 60 },
          hp: { min: 15, max: 200 }
        };
        const { shorten: s, hp: h } = bounds;
        const result = fmin.nelderMead(([shorten, hp]) => {
          if (shorten < s.min || shorten > s.max || hp < h.min || hp > h.max) {
            return SWR_MAX;
          }
          const z1 = Z(z.r, z.x - shorten);
          const z2 = addShuntReactance(z1, hp);
          return calcSWR(z2);
        }, [(s.min + s.max) / 2, (h.min + h.max) / 2]);
        return {
          shortening: Math.round(result.x[0]),
          hairpinX: Math.round(result.x[1])
        };
      },

      calc(p, zToScreen) {
        const antZ = Z(p.antR, p.antX);
        // Shortening path
        const shortenPath = [];
        for (let i = 0; i <= PATH_STEPS; i++) {
          const z = Z(p.antR, p.antX - p.shortening * (i / PATH_STEPS));
          shortenPath.push(zToScreen(z));
        }
        const afterShorten = Z(p.antR, p.antX - p.shortening);
        // Hairpin inductance arc along constant-G circle
        const hpArc = calcShuntArc(afterShorten, p.hairpinX, zToScreen);
        return {
          origPt: zToScreen(antZ),
          shortenedPt: zToScreen(afterShorten),
          finalPt: hpArc.endPt,
          afterShorten,
          finalZ: hpArc.endZ,
          shortenPath,
          hpArc,
          swr: calcSWR(hpArc.endZ)
        };
      },

      physical(p, base) {
        const diam = parseFloat(p.elementDiamMm);
        let shortenMm = null;
        let shortenPct = null;
        if (diam && diam > 0) {
          const z0Ant = 276 * Math.log10(base.lambdaMm / (2 * diam));
          const deltaLOverLambda = p.shortening / (z0Ant * Math.PI);
          shortenMm = deltaLOverLambda * base.lambdaMm / 2;
          shortenPct = (deltaLOverLambda / 0.5) * 100;
        }
        return { shortenMm, shortenPct };
      },

      SmithOverlay: ({ result, state }) => (
        <>
          {/* Shortening path */}
          {result.shortenPath.length > 1 && (
            <path
              d={pointsToPath(result.shortenPath)}
              fill="none" stroke={COLORS.step1} strokeWidth="3" strokeDasharray="6,4" strokeLinecap="round"
            />
          )}
          {/* Hairpin path - true arc */}
          <path
            d={result.hpArc.arcPath}
            fill="none" stroke={COLORS.hairpin} strokeWidth="3" strokeLinecap="round"
          />
          {/* Arrows */}
          {result.shortenPath.length > 3 && (
            <ArrowHead x={result.shortenedPt.x} y={result.shortenedPt.y}
              angle={getArrowAngle(result.shortenPath, result.shortenedPt)} color={COLORS.step1} />
          )}
          <ArrowHead x={result.finalPt.x} y={result.finalPt.y}
            angle={result.hpArc.arrowAngle} color={COLORS.hairpin} />
          {/* Points */}
          <circle cx={result.origPt.x} cy={result.origPt.y} r="10" fill={COLORS.orig} stroke="#fff" strokeWidth="2" />
          <text x={result.origPt.x + 14} y={result.origPt.y + 4}
            fill={COLORS.orig} fontSize="11" fontWeight="600">
            {'\u2460'} {Z(state.antR, state.antX).formatLabel()}
          </text>
          <circle cx={result.shortenedPt.x} cy={result.shortenedPt.y} r="7" fill={COLORS.step1} stroke="#fff" strokeWidth="2" />
          <text x={result.shortenedPt.x + 12} y={result.shortenedPt.y - 8}
            fill={COLORS.step1} fontSize="10" fontWeight="600">
            {'\u2461'} {result.afterShorten.formatLabel()}
          </text>
          <circle cx={result.finalPt.x} cy={result.finalPt.y} r="10" fill={COLORS.final} stroke="#fff" strokeWidth="2" />
          <text x={result.finalPt.x + 14} y={result.finalPt.y + 4} fill={COLORS.final} fontSize="11" fontWeight="600">
            {'\u2462'} {result.finalZ.formatLabel()}
          </text>
        </>
      ),

      Controls: ({ state, result, physical, setNum }) => (
        <>
          <ControlPanel color={COLORS.orig} title={'\u2460 ANTENNA IMPEDANCE'} tooltip="Starting impedance of the antenna feedpoint">
            <label className="control-label">
              <span className="control-text">Resistance: {state.antR}{'\u03A9'}</span>
              <input type="range" min="10" max="150" value={state.antR}
                onChange={setNum('antR')}
                aria-label="Antenna resistance"
                className="control-slider" style={{ accentColor: COLORS.orig }} />
            </label>
            <label className="control-label">
              <span className="control-text">
                Reactance: {state.antX >= 0 ? '+' : ''}j{state.antX}{'\u03A9'} {state.antX > 0 ? '(L)' : state.antX < 0 ? '(C)' : ''}
              </span>
              <input type="range" min="-100" max="100" value={state.antX}
                onChange={setNum('antX')}
                aria-label="Antenna reactance"
                className="control-slider" style={{ accentColor: COLORS.orig }} />
            </label>
            <div className="impedance-display">
              Z = {state.antR} {state.antX >= 0 ? '+' : '\u2212'} j{Math.abs(state.antX)} {'\u03A9'}
            </div>
          </ControlPanel>

          <ControlPanel color={COLORS.step1} title={'\u2461 SHORTEN ELEMENT'} tooltip="Capacitive reactance from shortened driven element">
            <label className="control-label">
              <span className="control-text">Capacitive reactance: {'\u2212'}j{state.shortening}{'\u03A9'}</span>
              <input type="range" min="0" max="60" value={state.shortening}
                onChange={setNum('shortening')}
                aria-label="Element shortening reactance"
                className="control-slider" style={{ accentColor: COLORS.step1 }} />
            </label>
            <div className="control-result">{'\u2192'} {result.afterShorten.format()} {'\u03A9'}</div>
            {physical && physical.shortenMm !== null ? (
              <div className="physical-hint">
                {'\u2248'} {physical.shortenMm.toFixed(1)} mm per side ({physical.shortenPct.toFixed(1)}% of {'\u03BB'}/2)
              </div>
            ) : (
              <div className="control-hint">Constant-R circle (series reactance)</div>
            )}
          </ControlPanel>

          <ControlPanel color={COLORS.hairpin} title={'\u2462 HAIRPIN (PARALLEL +jX)'} tooltip="Shunt inductor transforms impedance up to 50\u03A9">
            <label className="control-label">
              <span className="control-text">Inductive reactance: +j{state.hairpinX}{'\u03A9'}</span>
              <input type="range" min="15" max="200" value={state.hairpinX}
                onChange={setNum('hairpinX')}
                aria-label="Hairpin reactance"
                className="control-slider" style={{ accentColor: COLORS.hairpin }} />
            </label>
            <div className="control-hint">Constant-G circle (shunt susceptance)</div>
          </ControlPanel>

          <div className={`result-panel ${result.swr < 1.5 ? 'good' : 'normal'}`}
            style={{ borderColor: result.swr < 1.5 ? COLORS.hairpin : COLORS.final }}
            aria-live="polite">
            <div className="control-header" style={{ color: COLORS.final }}>MATCHED IMPEDANCE</div>
            <div className="result-z">Z = {result.finalZ.format()} {'\u03A9'}</div>
            <div className={`result-swr ${getSWRClass(result.swr)}`}>
              SWR = {result.swr.toFixed(3)} : 1
            </div>
          </div>
        </>
      ),

      Diagram: () => (
        <svg viewBox="0 0 450 130" className="diagram-svg">
          {/* Driven element - split with gap */}
          <line x1="50" y1="50" x2="212" y2="50" stroke={COLORS.element} strokeWidth="6" strokeLinecap="round" />
          <line x1="238" y1="50" x2="400" y2="50" stroke={COLORS.element} strokeWidth="6" strokeLinecap="round" />
          <text x="131" y="35" fill={COLORS.element} fontSize="10" textAnchor="middle">&lt; λ/4</text>
          <text x="319" y="35" fill={COLORS.element} fontSize="10" textAnchor="middle">&lt; λ/4</text>
          <path d="M 215 56 L 215 90 Q 215 100 225 100 Q 235 100 235 90 L 235 56"
            fill="none" stroke={COLORS.hairpin} strokeWidth="4" strokeLinecap="round" />
          <text x="225" y="118" fill={COLORS.hairpin} fontSize="9" textAnchor="middle">Hairpin (+jX)</text>
          <line x1="215" y1="56" x2="150" y2="56" stroke={COLORS.wire} strokeWidth="2" />
          <line x1="235" y1="56" x2="235" y2="70" stroke={COLORS.wire} strokeWidth="2" />
          <line x1="235" y1="70" x2="150" y2="70" stroke={COLORS.wire} strokeWidth="2" />
          <line x1="150" y1="56" x2="150" y2="70" stroke={COLORS.coax} strokeWidth="3" />
          <line x1="150" y1="63" x2="100" y2="63" stroke={COLORS.coax} strokeWidth="3" />
          <text x="75" y="67" fill={COLORS.coax} fontSize="9" textAnchor="middle">50Ω</text>
        </svg>
      ),

      Legend: () => (
        <>
          <line x1="0" y1="0" x2="20" y2="0" stroke={COLORS.step1} strokeWidth="3" strokeDasharray="6,4" />
          <text x="26" y="4" fill={COLORS.step1} fontSize="9">{'\u2461'} Shorten</text>
          <line x1="0" y1="16" x2="20" y2="16" stroke={COLORS.hairpin} strokeWidth="3" />
          <text x="26" y="20" fill={COLORS.hairpin} fontSize="9">{'\u2462'} Hairpin</text>
        </>
      ),

      Info: () => (
        <div className="info">
          <strong>Beta (Hairpin) Match:</strong> Shorten the driven element to add capacitive reactance,
          then use a parallel inductor (hairpin) to transform up to 50{'\u03A9'}. Best for low-Z antennas like Yagis.
        </div>
      ),
    };

    /** OCFD mode — all mode-specific behavior in one object */
    const ocfdMode = {
      key: 'ocfd',
      title: 'Off-Center Fed Doublet',
      buttonLabel: 'OCFD',
      activeClass: 'active-ocfd',
      diagramTitle: 'OFF-CENTER FED DOUBLET',
      hasAutoTune: false,
      showElementDiam: false,
      presets: OCFD_PRESETS,
      impedanceKeys: { r: 'ocfdR', x: 'ocfdX' },

      serializeUrl(p) {
        return {
          [URL_KEYS.ocfdR]: Math.round(p.ocfdR),
          [URL_KEYS.ocfdX]: Math.round(p.ocfdX),
          [URL_KEYS.feedOffset]: Math.round(p.feedOffset),
          [URL_KEYS.feedlineZ0]: p.feedlineZ0,
        };
      },

      tune: null,

      calc(p, zToScreen) {
        const centerZ = Z(p.ocfdR, p.ocfdX);
        const z0 = p.feedlineZ0;
        const alpha = p.feedOffset / 100;
        const factor = 1 / Math.cos(Math.PI * alpha) ** 2;
        const feedZ = Z(p.ocfdR * factor, p.ocfdX * factor);
        const centerPt = zToScreen(centerZ);
        const feedPt = zToScreen(feedZ);
        // Trajectory path: impedance as offset sweeps from 0 to current value
        const trajectoryPath = [];
        for (let i = 0; i <= PATH_STEPS; i++) {
          const a = alpha * (i / PATH_STEPS);
          const f = 1 / Math.cos(Math.PI * a) ** 2;
          const z = Z(p.ocfdR * f, p.ocfdX * f);
          if (z.r > 0 && z.r < PATH_R_MAX) {
            trajectoryPath.push(zToScreen(z));
          }
        }
        const swrs = FEEDLINE_IMPEDANCES.map(fl => ({
          z0: fl,
          swr: calcSWRForZ0(feedZ, fl)
        }));
        const selectedSwr = calcSWRForZ0(feedZ, z0);
        return { centerZ, feedZ, centerPt, feedPt, swrs, swr: selectedSwr, z0, trajectoryPath };
      },

      physical(p, base) {
        const alpha = p.feedOffset / 100;
        const halfDipole = base.lambdaMm / 2;
        return {
          ocfdL1Mm: halfDipole * (0.5 - alpha),
          ocfdL2Mm: halfDipole * (0.5 + alpha),
        };
      },

      SmithOverlay: ({ result }) => (
        <>
          {/* Trajectory path from center to feed point */}
          {result.trajectoryPath.length > 1 && (
            <path
              d={pointsToPath(result.trajectoryPath)}
              fill="none" stroke={COLORS.ocfd} strokeWidth="2" strokeDasharray="4,3" strokeLinecap="round" opacity="0.6"
            />
          )}
          {/* Center impedance point */}
          <circle cx={result.centerPt.x} cy={result.centerPt.y} r="8" fill={COLORS.orig} stroke="#fff" strokeWidth="2" />
          <text x={result.centerPt.x - 14} y={result.centerPt.y - 12}
            fill={COLORS.orig} fontSize="10" fontWeight="600" textAnchor="end">
            {'\u2460'} {result.centerZ.formatLabel()}
          </text>
          {/* Feed impedance point */}
          <circle cx={result.feedPt.x} cy={result.feedPt.y} r="10" fill={COLORS.ocfd} stroke="#fff" strokeWidth="2" />
          <text x={result.feedPt.x + 14} y={result.feedPt.y + 4}
            fill={COLORS.ocfd} fontSize="11" fontWeight="600">
            {'\u2461'} {result.feedZ.formatLabel()}
          </text>
        </>
      ),

      Controls: ({ state, result, physical, setNum, set }) => {
        return (
          <>
            <ControlPanel color={COLORS.orig} title={'\u2460 CENTER-FEED IMPEDANCE'} tooltip="Impedance at the center of the dipole">
              <label className="control-label">
                <span className="control-text">Resistance: {state.ocfdR}{'\u03A9'}</span>
                <input type="range" min="10" max="150" value={state.ocfdR}
                  onChange={setNum('ocfdR')}
                  aria-label="OCFD center resistance"
                  className="control-slider" style={{ accentColor: COLORS.orig }} />
              </label>
              <label className="control-label">
                <span className="control-text">
                  Reactance: {state.ocfdX >= 0 ? '+' : ''}j{state.ocfdX}{'\u03A9'} {state.ocfdX > 0 ? '(L)' : state.ocfdX < 0 ? '(C)' : ''}
                </span>
                <input type="range" min="-100" max="100" value={state.ocfdX}
                  onChange={setNum('ocfdX')}
                  aria-label="OCFD center reactance"
                  className="control-slider" style={{ accentColor: COLORS.orig }} />
              </label>
              <div className="impedance-display">
                Z{'\u2080'} = {state.ocfdR} {state.ocfdX >= 0 ? '+' : '\u2212'} j{Math.abs(state.ocfdX)} {'\u03A9'}
              </div>
            </ControlPanel>

            <ControlPanel color={COLORS.ocfd} title={'\u2461 FEED OFFSET'} tooltip="Distance from center as % of half-length">
              <label className="control-label">
                <span className="control-text">Offset: {state.feedOffset}% from center</span>
                <input type="range" min="0" max="48" step="1" value={state.feedOffset}
                  onChange={setNum('feedOffset')}
                  aria-label="Feed offset"
                  className="control-slider" style={{ accentColor: COLORS.ocfd }} />
              </label>
              {physical && (
                <div className="physical-hint">
                  L{'\u2081'} = {physical.ocfdL1Mm >= 1000 ? (physical.ocfdL1Mm / 1000).toFixed(2) + 'm' : Math.round(physical.ocfdL1Mm) + 'mm'}
                  {' / '}
                  L{'\u2082'} = {physical.ocfdL2Mm >= 1000 ? (physical.ocfdL2Mm / 1000).toFixed(2) + 'm' : Math.round(physical.ocfdL2Mm) + 'mm'}
                </div>
              )}
            </ControlPanel>

            <ControlPanel color={COLORS.ocfd} title={'\u2462 FEEDLINE IMPEDANCE'} tooltip="Characteristic impedance of the feedline">
              <div className="feedline-selector">
                {FEEDLINE_IMPEDANCES.map(z0 => (
                  <button
                    key={z0}
                    className={`btn preset-btn ${state.feedlineZ0 === z0 ? 'active' : ''}`}
                    onClick={() => set({ feedlineZ0: z0 })}
                    aria-label={`${z0} ohm feedline`}
                  >
                    {z0}{'\u03A9'}
                  </button>
                ))}
              </div>
            </ControlPanel>

            <div className="result-panel normal" style={{ borderColor: COLORS.ocfd }} aria-live="polite">
              <div className="control-header" style={{ color: COLORS.ocfd }}>FEED IMPEDANCE</div>
              <div className="result-z">Z = {result.feedZ.format()} {'\u03A9'}</div>
              <div className="result-swr" style={{ marginBottom: 6 }}>
                <span className={getSWRClass(result.swr)}>
                  SWR ({state.feedlineZ0}{'\u03A9'}) = {result.swr.toFixed(3)} : 1
                </span>
              </div>
              <div className="swr-table">
                {result.swrs.filter(s => s.z0 !== state.feedlineZ0).map(({ z0, swr }) => (
                  <div key={z0} className="swr-row">
                    <span className="swr-row-label">{z0}{'\u03A9'} line:</span>
                    <span className={`swr-row-value ${getSWRClass(swr)}`}>
                      SWR = {swr.toFixed(2)} : 1
                    </span>
                  </div>
                ))}
              </div>
            </div>
          </>
        );
      },

      Diagram: ({ state, physical }) => {
        const alpha = state.feedOffset / 100;
        const wireLeft = 50;
        const wireRight = 400;
        const wireLen = wireRight - wireLeft;
        const wireCenter = (wireLeft + wireRight) / 2;
        const wireY = 50;
        const feedX = wireCenter + alpha * (wireLen / 2);
        const feedXClamped = Math.min(feedX, wireRight - 10);
        return (
          <svg viewBox="0 0 450 130" className="diagram-svg">
            {/* Full dipole wire */}
            <line x1={wireLeft} y1={wireY} x2={wireRight} y2={wireY}
              stroke={COLORS.element} strokeWidth="6" strokeLinecap="round" />
            {/* Center marker */}
            <circle cx={wireCenter} cy={wireY} r="3" fill="#333" />
            <text x={wireCenter} y={wireY - 10} fill="#555" fontSize="9" textAnchor="middle">center</text>
            {/* Feed point */}
            <circle cx={feedXClamped} cy={wireY} r="5" fill={COLORS.ocfd} />
            {/* Feedline dropping down */}
            <line x1={feedXClamped} y1={wireY} x2={feedXClamped} y2={95}
              stroke={COLORS.coax} strokeWidth="3" />
            <text x={feedXClamped} y={110} fill={COLORS.coax} fontSize="9" textAnchor="middle">Feedline</text>
            {/* L1 label (short side = left of feed) */}
            <line x1={wireLeft} y1={wireY + 20} x2={feedXClamped} y2={wireY + 20}
              stroke={COLORS.orig} strokeWidth="1" />
            <line x1={wireLeft} y1={wireY + 16} x2={wireLeft} y2={wireY + 24}
              stroke={COLORS.orig} strokeWidth="1" />
            <line x1={feedXClamped} y1={wireY + 16} x2={feedXClamped} y2={wireY + 24}
              stroke={COLORS.orig} strokeWidth="1" />
            <text x={(wireLeft + feedXClamped) / 2} y={wireY + 34}
              fill={COLORS.orig} fontSize="9" textAnchor="middle">
              {physical ? `L₁ = ${physical.ocfdL1Mm >= 1000 ? (physical.ocfdL1Mm / 1000).toFixed(2) + 'm' : Math.round(physical.ocfdL1Mm) + 'mm'}` : 'L₁ (short)'}
            </text>
            {/* L2 label (long side = right of feed) */}
            <line x1={feedXClamped} y1={wireY + 20} x2={wireRight} y2={wireY + 20}
              stroke={COLORS.ocfd} strokeWidth="1" />
            <line x1={feedXClamped} y1={wireY + 16} x2={feedXClamped} y2={wireY + 24}
              stroke={COLORS.ocfd} strokeWidth="1" />
            <line x1={wireRight} y1={wireY + 16} x2={wireRight} y2={wireY + 24}
              stroke={COLORS.ocfd} strokeWidth="1" />
            <text x={(feedXClamped + wireRight) / 2} y={wireY + 34}
              fill={COLORS.ocfd} fontSize="9" textAnchor="middle">
              {physical ? `L₂ = ${physical.ocfdL2Mm >= 1000 ? (physical.ocfdL2Mm / 1000).toFixed(2) + 'm' : Math.round(physical.ocfdL2Mm) + 'mm'}` : 'L₂ (long)'}
            </text>
            {/* Total length */}
            <text x={wireCenter} y={wireY - 26} fill={COLORS.element} fontSize="10" textAnchor="middle">
              {physical ? `Dipole ≈ ${(physical.lambdaMm / 2000).toFixed(2)}m (λ/2)` : 'Dipole ≈ λ/2'}
            </text>
            {/* Offset label */}
            <text x={feedXClamped} y={wireY - 10} fill={COLORS.ocfd} fontSize="9" textAnchor="middle">
              {state.feedOffset}% off-center
            </text>
          </svg>
        );
      },

      Legend: () => (
        <>
          <circle cx="5" cy="0" r="5" fill={COLORS.orig} />
          <text x="16" y="4" fill={COLORS.orig} fontSize="9">{'\u2460'} Center Z</text>
          <line x1="0" y1="16" x2="10" y2="16" stroke={COLORS.ocfd} strokeWidth="2" strokeDasharray="4,3" />
          <text x="16" y="20" fill={COLORS.ocfd} fontSize="9">Offset trajectory</text>
          <circle cx="5" cy="32" r="5" fill={COLORS.ocfd} />
          <text x="16" y="36" fill={COLORS.ocfd} fontSize="9">{'\u2461'} Feed Z</text>
        </>
      ),

      Info: () => (
        <div className="info">
          <strong>Off-Center Fed Doublet:</strong> A half-wave dipole fed off-center presents higher impedance,
          enabling use with 300{'\u03A9'} or 450{'\u03A9'} balanced feedline.
          Z{'\u2090'}({'\u03B1'}) = Z{'\u2080'} / cos{'\u00B2'}({'\u03C0\u03B1'}) where {'\u03B1'} is the feed offset ratio.
        </div>
      ),
    };

    /** @type {Object} Per-mode object map */
    const MODE_MAP = Object.freeze({
      [MODES.GAMMA]: gammaMode,
      [MODES.HAIRPIN]: hairpinMode,
      [MODES.OCFD]: ocfdMode,
    });

    /**
     * Calculate base physical parameters from frequency
     * @param {string} freqMHz - Frequency in MHz
     * @returns {Object|null} { lambda, lambdaMm } or null if no valid frequency
     */
    const calcBasePhysical = (freqMHz) => {
      const freq = parseFloat(freqMHz);
      if (!freq || freq <= 0) return null;
      const lambda = C_SPEED / (freq * 1e6);
      return { lambda, lambdaMm: lambda * 1000 };
    };

    // ============================================================
    // URL Parameter Utilities
    // ============================================================

    /**
     * Parse float from URL param with default
     * @param {string|null} val - URL parameter value
     * @param {number} def - Default value
     * @returns {number}
     */
    const parseParam = (val, def) => {
      if (val === null) return def;
      const n = parseFloat(val);
      return isNaN(n) ? def : n;
    };

    /** @type {Object} Default parameter values */
    const DEFAULTS = Object.freeze({
      mode: MODES.GAMMA,
      antR: 73,
      antX: 43,
      tapRatio: 1.0,
      gammaRodX: 300,
      seriesCapX: 30,
      shortening: 15,
      hairpinX: 50,
      freqMHz: '',
      elementDiamMm: '2',
      ocfdR: 73,
      ocfdX: 43,
      feedOffset: 33,
      feedlineZ0: 50
    });

    /**
     * Check if all values match defaults
     * @param {Object} values - Current state values
     * @returns {boolean}
     */
    const isAtDefaults = (values) =>
      Object.keys(DEFAULTS).every(key => values[key] === DEFAULTS[key]);

    /**
     * Read initial state from URL parameters
     * @returns {Object} Initial state values from URL
     */
    const getUrlParams = () => {
      const params = new URLSearchParams(window.location.search);
      const modeParam = params.get(URL_KEYS.mode);
      return {
        mode: Object.values(MODES).includes(modeParam) ? modeParam : DEFAULTS.mode,
        antR: parseParam(params.get(URL_KEYS.antR), DEFAULTS.antR),
        antX: parseParam(params.get(URL_KEYS.antX), DEFAULTS.antX),
        tapRatio: parseParam(params.get(URL_KEYS.tapRatio), DEFAULTS.tapRatio),
        gammaRodX: parseParam(params.get(URL_KEYS.gammaRodX), DEFAULTS.gammaRodX),
        seriesCapX: parseParam(params.get(URL_KEYS.seriesCapX), DEFAULTS.seriesCapX),
        shortening: parseParam(params.get(URL_KEYS.shortening), DEFAULTS.shortening),
        hairpinX: parseParam(params.get(URL_KEYS.hairpinX), DEFAULTS.hairpinX),
        freqMHz: params.get(URL_KEYS.freqMHz) || DEFAULTS.freqMHz,
        elementDiamMm: params.get(URL_KEYS.elementDiamMm) || DEFAULTS.elementDiamMm,
        ocfdR: parseParam(params.get(URL_KEYS.ocfdR), DEFAULTS.ocfdR),
        ocfdX: parseParam(params.get(URL_KEYS.ocfdX), DEFAULTS.ocfdX),
        feedOffset: parseParam(params.get(URL_KEYS.feedOffset), DEFAULTS.feedOffset),
        feedlineZ0: parseParam(params.get(URL_KEYS.feedlineZ0), DEFAULTS.feedlineZ0)
      };
    };

    const initialParams = getUrlParams();

    /**
     * Get CSS class for SWR value
     * @param {number} swr - Standing wave ratio
     * @returns {string} CSS class name
     */
    const getSWRClass = (swr) => {
      if (swr < SWR_THRESHOLDS.excellent) return 'swr-excellent';
      if (swr < SWR_THRESHOLDS.good) return 'swr-good';
      if (swr < SWR_THRESHOLDS.ok) return 'swr-ok';
      return 'swr-poor';
    };

    // ============================================================
    // Main Component
    // ============================================================

    function AntennaMatching() {
      const [p, setP] = useState(initialParams);
      const set = (updates) => setP(prev => ({ ...prev, ...updates }));

      /** Helper for numeric input onChange handlers */
      const setNum = (key) => (e) => set({ [key]: Number(e.target.value) });

      /** Helper for string input onChange handlers */
      const setStr = (key) => (e) => set({ [key]: e.target.value });

      const { mode, freqMHz, elementDiamMm } = p;
      const modeDef = MODE_MAP[mode];

      // Update URL when state changes
      useEffect(() => {
        if (isAtDefaults(p)) {
          window.history.replaceState(null, '', window.location.pathname);
          return;
        }

        const params = new URLSearchParams();
        params.set(URL_KEYS.mode, p.mode);
        const modeParams = modeDef.serializeUrl(p);
        Object.entries(modeParams).forEach(([k, v]) => params.set(k, v));
        if (p.freqMHz) params.set(URL_KEYS.freqMHz, p.freqMHz);
        if (p.elementDiamMm && p.elementDiamMm !== DEFAULTS.elementDiamMm) params.set(URL_KEYS.elementDiamMm, p.elementDiamMm);

        const newUrl = `${window.location.pathname}?${params.toString()}`;
        window.history.replaceState(null, '', newUrl);
      }, [p]);

      // Hooks
      const { zToScreen, rCircles, xArcs, createXArc } = useSmithChart();
      const result = useMemo(() => modeDef.calc(p, zToScreen), [modeDef, p, zToScreen]);
      const didAutoTune = useRef(false);

      // Physical calculations (shared base + mode-specific)
      const physical = useMemo(() => {
        const base = calcBasePhysical(freqMHz);
        return base ? { ...base, ...modeDef.physical(p, base) } : null;
      }, [modeDef, p, freqMHz]);

      const handleAutoTune = useCallback(() => {
        if (modeDef.tune) {
          const { r: rKey, x: xKey } = modeDef.impedanceKeys;
          set(modeDef.tune(Z(p[rKey], p[xKey])));
        }
      }, [modeDef, p]);

      // Auto-tune on initial load if no URL parameters provided
      useEffect(() => {
        if (!didAutoTune.current && !window.location.search && modeDef.hasAutoTune) {
          didAutoTune.current = true;
          handleAutoTune();
        }
      }, [handleAutoTune, modeDef]);

      const handlePreset = (preset) => {
        const { r, x, label, ...extra } = preset;
        const { r: rKey, x: xKey } = modeDef.impedanceKeys;
        const updates = { [rKey]: r, [xKey]: x, ...extra };
        if (modeDef.tune) {
          Object.assign(updates, modeDef.tune(Z(r, x)));
        }
        set(updates);
      };

      const isPresetActive = (preset) => {
        const { r: rKey, x: xKey } = modeDef.impedanceKeys;
        if (p[rKey] !== preset.r || p[xKey] !== preset.x) return false;
        if ('feedOffset' in preset) return p.feedOffset === preset.feedOffset;
        return true;
      };

      return (
        <div className="app">
          {/* Mode Toggle */}
          <div className="mode-toggle">
            {Object.entries(MODE_MAP).map(([modeKey, def]) => (
              <button
                key={modeKey}
                className={`btn mode-btn ${mode === modeKey ? def.activeClass : ''}`}
                onClick={() => set({ mode: modeKey })}
              >
                {def.buttonLabel}
              </button>
            ))}
          </div>

          <h1 className="title">{modeDef.title}</h1>
          <div className="footer" style={{ marginTop: '-12px' }}>By AI6KG &lt;<a href="mailto:ai6kg@arrl.net">ai6kg@arrl.net</a>&gt;</div>

          {/* Presets */}
          <div className="presets">
            {modeDef.presets.map((preset) => (
              <button
                key={preset.label}
                className={`btn preset-btn ${isPresetActive(preset) ? 'active' : ''}`}
                onClick={() => handlePreset(preset)}
              >
                {preset.label}
              </button>
            ))}
            {modeDef.hasAutoTune && (
              <button
                className={`btn auto-tune-btn ${mode}`}
                onClick={handleAutoTune}
                data-tooltip="Find optimal match parameters"
              >
                Auto-Tune
              </button>
            )}
          </div>

          {/* Physical Parameters (optional) */}
          <div className="physical-params">
            <label>
              Freq (MHz):
              <input
                type="number"
                value={freqMHz}
                onChange={setStr('freqMHz')}
                min="1"
                max="3000"
                step="0.1"
              />
            </label>
            {modeDef.showElementDiam && (
              <label>
                Element {'\u2300'} (mm):
                <input
                  type="number"
                  value={elementDiamMm}
                  onChange={setStr('elementDiamMm')}
                  min="0.1"
                  max="100"
                  step="0.1"
                />
              </label>
            )}
            <span style={{ color: '#555', alignSelf: 'center', minWidth: '90px' }}>
              {physical ? `\u03BB = ${(physical.lambdaMm / 1000).toFixed(2)}m` : ''}
            </span>
            <button
              className="btn preset-btn"
              onClick={() => navigator.clipboard.writeText(window.location.href)}
              style={{ alignSelf: 'center' }}
              data-tooltip="Copy shareable link to clipboard"
            >
              Copy URL
            </button>
            <button
              className="btn preset-btn"
              onClick={() => set({ ...DEFAULTS, mode: p.mode })}
              style={{ alignSelf: 'center' }}
              data-tooltip="Reset all parameters to defaults"
            >
              Reset
            </button>
          </div>

          <div className="main-content">
            {/* Smith Chart */}
            <svg width={SIZE} height={SIZE} viewBox={`0 0 ${SIZE} ${SIZE}`} className="smith-chart">
              {/* Outer circle */}
              <circle cx={CX} cy={CY} r={RADIUS} fill="none" stroke={COLORS.gridOuter} strokeWidth="2" />

              {/* Resistance circles */}
              {rCircles.map(({ r, cx, radius }) => (
                <circle key={`r-${r}`} cx={cx} cy={CY} r={radius} fill="none" stroke={COLORS.grid} strokeWidth="1" />
              ))}

              {/* Reactance arcs */}
              {xArcs.map(({ x, cx, cy, radius }) => {
                const pts = createXArc(x, cx, cy, radius);
                if (pts.length < 2) return null;
                return <path key={`x-${x}`} d={pointsToPath(pts)} fill="none" stroke={COLORS.grid} strokeWidth="1" />;
              })}

              {/* Center line */}
              <line x1={CX - RADIUS} y1={CY} x2={CX + RADIUS} y2={CY} stroke={COLORS.gridCenter} strokeWidth="1" />

              {/* Labels */}
              <text x={CX - RADIUS - 8} y={CY + 4} fill={COLORS.label} fontSize="10" textAnchor="end">0</text>
              <text x={CX + RADIUS + 8} y={CY + 4} fill={COLORS.label} fontSize="10" textAnchor="start">{'\u221E'}</text>
              <text x={CX} y={CY - 8} fill={COLORS.label} fontSize="9" textAnchor="middle">50{'\u03A9'}</text>
              <text x={CX} y={CY - RADIUS - 8} fill={COLORS.label} fontSize="9" textAnchor="middle">+jX</text>
              <text x={CX} y={CY + RADIUS + 16} fill={COLORS.label} fontSize="9" textAnchor="middle">{'\u2212'}jX</text>

              {/* Mode-specific overlay */}
              <modeDef.SmithOverlay result={result} state={p} />

              {/* Target impedance */}
              {(() => {
                const targetZ0 = mode === MODES.OCFD ? p.feedlineZ0 : Z0;
                const pt = zToScreen(Z(targetZ0, 0));
                return (
                  <>
                    <circle cx={pt.x} cy={pt.y} r="6" fill="none" stroke={COLORS.hairpin} strokeWidth="2" strokeDasharray="3,3" />
                    {targetZ0 !== Z0 && (
                      <text x={pt.x} y={pt.y - 10} fill={COLORS.label} fontSize="9" textAnchor="middle">
                        {targetZ0}{'\u03A9'}
                      </text>
                    )}
                  </>
                );
              })()}

              {/* Legend */}
              <g transform={`translate(${CX - RADIUS + 10}, ${CY + RADIUS - 80})`}>
                <modeDef.Legend />
              </g>
            </svg>

            {/* Controls */}
            <div className="controls">
              <modeDef.Controls state={p} result={result} physical={physical}
                setNum={setNum} set={set} freqMHz={freqMHz} />
            </div>
          </div>

          {/* Physical diagram */}
          <div className="diagram-container">
            <div className="diagram-title">{modeDef.diagramTitle}</div>
            <modeDef.Diagram state={p} physical={physical} />
          </div>

          {/* Info */}
          <modeDef.Info />

          {/* Footer */}
          <div className="footer">
            {'\u00A9'} 2025-2026 Christopher Hoover. <a href="https://github.com/charlieh0tel/ham_radio/blob/master/LICENSE">MIT License</a>.{' '}
            <a href="https://github.com/charlieh0tel/ham_radio">GitHub</a>.{' '}
            <a href="https://github.com/charlieh0tel/ham_radio/issues">Bugs &amp; Feedback</a>
          </div>
        </div>
      );
    }

    ReactDOM.createRoot(document.getElementById('root')).render(<AntennaMatching />);
  </script>
</body>
</html>
