<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Antenna Impedance Matching - Smith Chart</title>
  <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script src="https://unpkg.com/mathjs@12/lib/browser/math.js"></script>
  <script src="https://unpkg.com/fmin@0.0.2/build/fmin.min.js"></script>
  <style>
    body { margin: 0; }

    /* Layout */
    .app {
      min-height: 100vh;
      background: #0a0a0a;
      color: #e0e0e0;
      font-family: "JetBrains Mono", "SF Mono", Monaco, Consolas, monospace;
      padding: 24px;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 20px;
    }

    .main-content {
      display: flex;
      gap: 32px;
      flex-wrap: wrap;
      justify-content: center;
    }

    /* Buttons - Base */
    .btn {
      border: none;
      border-radius: 6px;
      cursor: pointer;
      font-family: inherit;
      font-weight: 600;
      transition: all 0.2s;
    }

    /* Mode Toggle */
    .mode-toggle {
      display: flex;
      gap: 8px;
      background: #1a1a1a;
      padding: 6px;
      border-radius: 8px;
    }

    .mode-btn {
      padding: 10px 20px;
      background: transparent;
      color: #888;
      font-size: 13px;
    }

    .mode-btn.active-gamma {
      background: #da77f2;
      color: #000;
    }

    .mode-btn.active-hairpin {
      background: #00ff88;
      color: #000;
    }

    /* Title */
    .title {
      font-size: 18px;
      font-weight: 500;
      letter-spacing: 0.05em;
      color: #fff;
      margin: 0;
      text-transform: uppercase;
    }

    /* Presets */
    .presets {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
      justify-content: center;
    }

    .preset-btn {
      padding: 8px 14px;
      background: #1a1a1a;
      color: #888;
      border: 1px solid #333;
      font-size: 11px;
      font-weight: 400;
    }

    .preset-btn.active {
      background: #333;
      color: #fff;
    }

    .auto-tune-btn {
      padding: 8px 20px;
      color: #000;
      font-size: 11px;
    }

    .auto-tune-btn.gamma { background: #da77f2; }
    .auto-tune-btn.hairpin { background: #00ff88; }

    /* Smith Chart */
    .smith-chart {
      background: #111;
      border-radius: 8px;
    }

    /* Controls */
    .controls {
      display: flex;
      flex-direction: column;
      gap: 12px;
      min-width: 300px;
    }

    .control-panel {
      background: #1a1a1a;
      padding: 14px;
      border-radius: 8px;
      border: 1px solid #333;
    }

    .control-header {
      font-size: 11px;
      margin-bottom: 10px;
      font-weight: 600;
    }

    .control-label {
      display: block;
      margin-bottom: 8px;
    }

    .control-label:last-of-type {
      margin-bottom: 0;
    }

    .control-text {
      font-size: 12px;
      color: #888;
    }

    .control-slider {
      width: 100%;
      margin-top: 4px;
    }

    .control-result {
      font-size: 11px;
      color: #aaa;
      margin-top: 6px;
    }

    .control-hint {
      font-size: 10px;
      color: #666;
      margin-top: 2px;
    }

    .impedance-display {
      margin-top: 8px;
      font-size: 13px;
      color: #fff;
      font-weight: 500;
    }

    /* Result Panel */
    .result-panel {
      padding: 14px;
      border-radius: 8px;
      border-width: 2px;
      border-style: solid;
    }

    .result-panel.good { background: #0a1a0a; border-color: #00ff88; }
    .result-panel.normal { background: #1a1a1a; }

    .result-z {
      font-size: 18px;
      color: #fff;
      margin-bottom: 6px;
      font-weight: 600;
    }

    .result-swr {
      font-size: 16px;
      font-weight: 600;
    }

    .swr-excellent { color: #00ff88; }
    .swr-good { color: #4ade80; }
    .swr-ok { color: #ffd43b; }
    .swr-poor { color: #ff6b6b; }

    /* Physical Diagram */
    .diagram-container {
      background: #111;
      padding: 20px;
      border-radius: 8px;
      max-width: 650px;
      width: 100%;
    }

    .diagram-title {
      color: #888;
      font-size: 11px;
      margin-bottom: 12px;
      text-align: center;
      font-weight: 600;
    }

    .diagram-svg {
      display: block;
      width: 100%;
    }

    /* Info */
    .info {
      max-width: 680px;
      font-size: 12px;
      color: #666;
      line-height: 1.6;
      text-align: center;
    }

    .info strong {
      color: #aaa;
    }

    /* Footer */
    .footer {
      font-size: 11px;
      color: #555;
      text-align: center;
      margin-top: 12px;
    }

    .footer a {
      color: #888;
    }

    /* Physical params */
    .physical-params {
      display: flex;
      gap: 16px;
      font-size: 11px;
      color: #666;
    }

    .physical-params label {
      display: flex;
      align-items: center;
      gap: 4px;
    }

    .physical-params input {
      width: 60px;
      padding: 4px 6px;
      background: #1a1a1a;
      border: 1px solid #333;
      border-radius: 4px;
      color: #aaa;
      font-family: inherit;
      font-size: 11px;
    }

    .physical-params input:focus {
      outline: none;
      border-color: #555;
    }

    .physical-hint {
      font-size: 10px;
      color: #888;
      margin-top: 4px;
    }

    /* Mobile responsive */
    @media (max-width: 800px) {
      .app {
        padding: 16px;
        gap: 16px;
      }

      .main-content {
        flex-direction: column;
        align-items: center;
      }

      .smith-chart {
        width: 100%;
        max-width: 400px;
        height: auto;
        aspect-ratio: 1;
      }

      .controls {
        min-width: unset;
        width: 100%;
        max-width: 400px;
      }

      .physical-params {
        flex-wrap: wrap;
        justify-content: center;
      }

      .mode-toggle {
        flex-wrap: wrap;
        justify-content: center;
      }

      .presets {
        justify-content: center;
      }

      .diagram-container {
        max-width: 100%;
      }
    }

    /* Tooltips */
    [data-tooltip] {
      position: relative;
    }

    [data-tooltip]:hover::after {
      content: attr(data-tooltip);
      position: absolute;
      bottom: 100%;
      left: 50%;
      transform: translateX(-50%);
      background: #333;
      color: #fff;
      padding: 6px 10px;
      border-radius: 4px;
      font-size: 11px;
      white-space: nowrap;
      z-index: 100;
      margin-bottom: 4px;
    }

    /* Print styles */
    @media print {
      .app {
        background: white;
        color: black;
        padding: 0;
      }

      .mode-toggle,
      .presets,
      .physical-params,
      input[type="range"],
      .footer a {
        display: none;
      }

      .control-panel,
      .result-panel {
        background: white;
        border: 1px solid #999;
        break-inside: avoid;
      }

      .control-header,
      .control-text,
      .control-result,
      .control-hint,
      .physical-hint,
      .diagram-title,
      .info,
      .info strong,
      .title {
        color: black;
      }

      .smith-chart,
      .diagram-container {
        background: white;
      }

      .footer {
        color: #666;
      }
    }
  </style>
</head>
<body>
  <div id="root"></div>
  <script type="text/babel">
    const { useState, useMemo, useCallback, useEffect } = React;
    const { complex, add, subtract, multiply, divide } = math;

    /**
     * Convert array of points to SVG path string
     * @param {ScreenPoint[]} points
     * @returns {string}
     */
    const pointsToPath = (points) =>
      points.map((p, i) => `${i === 0 ? 'M' : 'L'} ${p.x} ${p.y}`).join(' ');

    // ============================================================
    // JSDoc Type Definitions
    // ============================================================

    /**
     * @typedef {Object} Impedance
     * @property {number} r - Resistance in ohms
     * @property {number} x - Reactance in ohms (positive = inductive, negative = capacitive)
     */

    /**
     * @typedef {Object} ReflectionCoefficient
     * @property {number} re - Real part of gamma
     * @property {number} im - Imaginary part of gamma
     */

    /**
     * @typedef {Object} ScreenPoint
     * @property {number} x - X coordinate on screen
     * @property {number} y - Y coordinate on screen
     */

    /**
     * @typedef {Object} GammaMatchResult
     * @property {ScreenPoint} origPt - Original impedance point
     * @property {ScreenPoint} afterTapPt - Point after tap ratio transformation
     * @property {ScreenPoint} afterShuntPt - Point after shunt inductance
     * @property {ScreenPoint} finalPt - Final matched impedance point
     * @property {Impedance} afterTap - Impedance after tap ratio
     * @property {Impedance} afterShunt - Impedance after shunt inductance
     * @property {Impedance} finalZ - Final matched impedance
     * @property {ScreenPoint[]} tapPath - Path for tap ratio transformation
     * @property {ScreenPoint[]} shuntPath - Path for shunt inductance
     * @property {ScreenPoint[]} seriesPath - Path for series capacitor
     * @property {number} swr - Standing wave ratio
     */

    /**
     * @typedef {Object} HairpinMatchResult
     * @property {ScreenPoint} origPt - Original impedance point
     * @property {ScreenPoint} shortenedPt - Point after shortening
     * @property {ScreenPoint} finalPt - Final matched impedance point
     * @property {Impedance} afterShorten - Impedance after shortening
     * @property {Impedance} finalZ - Final matched impedance
     * @property {ScreenPoint[]} shortenPath - Path for shortening transformation
     * @property {ScreenPoint[]} hpPath - Path for hairpin inductance
     * @property {number} swr - Standing wave ratio
     */

    /**
     * @typedef {Object} SmithChartGeometry
     * @property {function(number, number): ScreenPoint} zToScreen - Convert impedance to screen coordinates
     * @property {Array<{r: number, cx: number, radius: number}>} rCircles - Constant resistance circles
     * @property {Array<{x: number, cx: number, cy: number, radius: number}>} xArcs - Constant reactance arcs
     * @property {function(number, number, number, number): ScreenPoint[]} createXArc - Create points for reactance arc
     */

    /**
     * @typedef {Object} Preset
     * @property {string} label - Display label
     * @property {number} r - Resistance value
     * @property {number} x - Reactance value
     */

    // ============================================================
    // Constants
    // ============================================================

    /** @type {number} Characteristic impedance */
    const Z0 = 50;

    /** @type {number} Smith chart size in pixels */
    const SIZE = 520;

    /** @type {number} Smith chart center X */
    const CX = SIZE / 2;

    /** @type {number} Smith chart center Y */
    const CY = SIZE / 2;

    /** @type {number} Smith chart radius */
    const RADIUS = SIZE / 2 - 45;

    /** @type {Object} Color palette */
    const COLORS = Object.freeze({
      orig: '#ff6b6b',
      step1: '#ffa94d',
      step2: '#da77f2',
      step3: '#66d9e8',
      final: '#4dabf7',
      hairpin: '#00ff88',
      coax: '#4dabf7',
      // Grid colors (dark to light)
      grid: '#444',
      gridOuter: '#555',
      gridCenter: '#666',
      label: '#888',
      element: '#666',
      wire: '#888'
    });

    /** @type {Preset[]} Antenna presets */
    const PRESETS = Object.freeze([
      { label: 'Dipole (73+j43Ω)', r: 73, x: 43 },
      { label: 'Yagi (25Ω)', r: 25, x: 0 },
      { label: 'Low-Z Yagi (18−j10Ω)', r: 18, x: -10 }
    ]);

    /** @type {number[]} Normalized resistance values for Smith chart circles */
    const R_VALUES = Object.freeze([0, 0.2, 0.5, 1, 2, 5]);

    /** @type {number[]} Normalized reactance values for Smith chart arcs */
    const X_VALUES = Object.freeze([0.2, 0.5, 1, 2, 5]);

    /** @type {number} Speed of light in m/s */
    const C_SPEED = 299792458;

    /** @type {number} Number of points for path generation */
    const PATH_STEPS = 50;

    /**
     * Starting reactance for shunt path animations.
     * High value ≈ open circuit (no shunt effect), so path visually starts
     * at the previous transformation point and sweeps along constant-G circle.
     * @type {number}
     */
    const SHUNT_X_START = 10000;

    /**
     * Path filtering limits - impedances outside these bounds are clipped
     * to keep paths within reasonable Smith chart region.
     */
    const PATH_R_MAX = 1000;
    const PATH_X_MAX = 500;

    /** Threshold below which shunt reactance is treated as zero (open circuit) */
    const SHUNT_X_MIN = 0.1;

    /** Maximum displayable SWR (returned when reflection coefficient >= 1) */
    const SWR_MAX = 99;

    /** @type {Object} SWR thresholds for color coding */
    const SWR_THRESHOLDS = Object.freeze({
      excellent: 1.2,
      good: 1.5,
      ok: 2.0
    });

    /** @type {Object} Auto-tune parameter bounds */
    const TUNE_BOUNDS = Object.freeze({
      gamma: {
        tap: { min: 1, max: 2.5 },
        rod: { min: 20, max: 400 },
        cap: { min: 0, max: 100 }
      },
      hairpin: {
        shorten: { min: 0, max: 60 },
        hp: { min: 15, max: 200 }
      }
    });

    /** @type {Object} Match mode constants */
    const MODES = Object.freeze({
      GAMMA: 'gamma',
      HAIRPIN: 'hairpin'
    });

    /** @type {Object} URL parameter keys */
    const URL_KEYS = Object.freeze({
      mode: 'mode',
      antR: 'r',
      antX: 'x',
      tapRatio: 'tap',
      gammaRodX: 'rod',
      seriesCapX: 'cap',
      shortening: 'short',
      hairpinX: 'hp',
      freqMHz: 'freq',
      elementDiamMm: 'diam'
    });

    // ============================================================
    // Impedance Math Utilities
    // ============================================================

    /**
     * Create complex number from resistance and reactance
     * @param {number} r - Resistance
     * @param {number} x - Reactance
     * @returns {Object} Complex number
     */
    const C = (r, x) => complex(r, x);

    /**
     * Convert complex number to impedance object
     * @param {Object} z - Complex number
     * @returns {Impedance}
     */
    const toRX = (z) => ({ r: z.re, x: z.im });

    /**
     * Convert impedance to reflection coefficient: Γ = (z - 1) / (z + 1)
     * @param {number} r - Resistance in ohms
     * @param {number} x - Reactance in ohms
     * @returns {ReflectionCoefficient}
     */
    const zToGamma = (r, x) => {
      const zNorm = C(r / Z0, x / Z0);
      const gamma = divide(subtract(zNorm, 1), add(zNorm, 1));
      return { re: gamma.re, im: gamma.im };
    };

    /**
     * Apply tap ratio transformation: Z_new = Z × n²
     * @param {number} r - Resistance
     * @param {number} x - Reactance
     * @param {number} ratio - Tap ratio (n)
     * @returns {Impedance}
     */
    const applyTapRatio = (r, x, ratio) => {
      const z = multiply(C(r, x), ratio * ratio);
      return toRX(z);
    };

    /**
     * Add shunt reactance: Y_total = Y + Y_shunt, Z = 1/Y_total
     * @param {number} r - Resistance
     * @param {number} x - Reactance
     * @param {number} xShunt - Shunt reactance value
     * @returns {Impedance}
     */
    const addShuntReactance = (r, x, xShunt) => {
      if (Math.abs(xShunt) < SHUNT_X_MIN) return { r, x };
      const z = C(r, x);
      const y = divide(1, z);
      const yShunt = C(0, -1 / xShunt);
      const yTotal = add(y, yShunt);
      const zNew = divide(1, yTotal);
      return toRX(zNew);
    };

    /**
     * Add series reactance: Z_new = Z + jX_series
     * @param {number} r - Resistance
     * @param {number} x - Reactance
     * @param {number} xSeries - Series reactance to add
     * @returns {Impedance}
     */
    const addSeriesReactance = (r, x, xSeries) => {
      const z = add(C(r, x), C(0, xSeries));
      return toRX(z);
    };

    /**
     * Calculate SWR from impedance
     * @param {number} r - Resistance
     * @param {number} x - Reactance
     * @returns {number} SWR value
     */
    const calcSWR = (r, x) => {
      const gamma = zToGamma(r, x);
      const gammaMag = Math.sqrt(gamma.re ** 2 + gamma.im ** 2);
      if (gammaMag >= 1) return SWR_MAX;
      return (1 + gammaMag) / (1 - gammaMag);
    };

    /**
     * Format impedance for display
     * @param {number} r - Resistance
     * @param {number} x - Reactance
     * @returns {string} Formatted string like "50.0 + j25.0"
     */
    const formatZ = (r, x) => `${r.toFixed(1)} ${x >= 0 ? '+' : '−'} j${Math.abs(x).toFixed(1)}`;

    // ============================================================
    // Custom Hooks
    // ============================================================

    /**
     * Hook for Smith chart geometry calculations
     * @returns {SmithChartGeometry}
     */
    const useSmithChart = () => {
      return useMemo(() => {
        /**
         * Convert reflection coefficient to screen coordinates
         * @param {ReflectionCoefficient} gamma
         * @returns {ScreenPoint}
         */
        const gammaToScreen = (gamma) => ({
          x: CX + gamma.re * RADIUS,
          y: CY - gamma.im * RADIUS
        });

        /**
         * Convert impedance to screen coordinates
         * @param {number} r - Resistance
         * @param {number} x - Reactance
         * @returns {ScreenPoint}
         */
        const zToScreen = (r, x) => gammaToScreen(zToGamma(r, x));

        /** Constant resistance circles */
        const rCircles = R_VALUES.map(r => ({
          r,
          cx: CX + (r / (r + 1)) * RADIUS,
          radius: RADIUS / (r + 1)
        }));

        /** Constant reactance arcs */
        const xArcs = X_VALUES.flatMap(x => [x, -x]).map(x => ({
          x,
          cx: CX + RADIUS,
          cy: CY - RADIUS / x,
          radius: Math.abs(RADIUS / x)
        }));

        /**
         * Create points for a reactance arc clipped to the Smith chart
         *
         * Constant-x arcs are circles with center at Γ = (1, 1/x) and radius 1/|x|.
         * They intersect the unit circle at (1, 0) and ((x²-1)/(1+x²), 2x/(1+x²)).
         *
         * @param {number} x - Normalized reactance value
         * @param {number} arcCx - Arc center X (screen coords)
         * @param {number} arcCy - Arc center Y (screen coords)
         * @param {number} arcRadius - Arc radius (screen coords)
         * @returns {ScreenPoint[]}
         */
        const createXArc = (x, arcCx, arcCy, arcRadius) => {
          const x2 = x * x;
          const denom = 1 + x2;

          // Exact intersection points on unit circle (screen coords)
          const p1x = CX + RADIUS;  // Infinity point (1, 0)
          const p1y = CY;
          const p2x = CX + (x2 - 1) / denom * RADIUS;
          const p2y = CY - 2 * x / denom * RADIUS;

          // Angles from arc center to each intersection
          const angle1 = Math.atan2(p1y - arcCy, p1x - arcCx);
          const angle2 = Math.atan2(p2y - arcCy, p2x - arcCx);

          // Determine sweep direction: we want to stay inside unit circle
          // Test midpoint of both possible paths
          const midAngleDirect = (angle1 + angle2) / 2;
          const midAngleAlt = midAngleDirect + (midAngleDirect > 0 ? -Math.PI : Math.PI);

          const testMid = (angle) => {
            const gx = (arcCx + arcRadius * Math.cos(angle) - CX) / RADIUS;
            const gy = (CY - (arcCy + arcRadius * Math.sin(angle))) / RADIUS;
            return gx * gx + gy * gy;
          };

          // Choose path where midpoint is inside unit circle (|Γ|² < 1)
          const goLongWay = testMid(midAngleDirect) > testMid(midAngleAlt);
          const endAngle = goLongWay
            ? angle2 + (angle2 > angle1 ? -2 : 2) * Math.PI
            : angle2;

          // Generate arc points
          const points = [{ x: p1x, y: p1y }];  // Start exactly at infinity point
          for (let i = 1; i < PATH_STEPS; i++) {
            const angle = angle1 + (endAngle - angle1) * i / PATH_STEPS;
            points.push({
              x: arcCx + arcRadius * Math.cos(angle),
              y: arcCy + arcRadius * Math.sin(angle)
            });
          }
          points.push({ x: p2x, y: p2y });  // End exactly at intersection
          return points;
        };

        return { zToScreen, rCircles, xArcs, createXArc };
      }, []);
    };

    /**
     * Hook for gamma match calculations
     * @param {number} antR - Antenna resistance
     * @param {number} antX - Antenna reactance
     * @param {number} tapRatio - Tap ratio
     * @param {number} gammaRodX - Gamma rod reactance
     * @param {number} seriesCapX - Series capacitor reactance
     * @returns {GammaMatchResult}
     */
    const useGammaMatch = (antR, antX, tapRatio, gammaRodX, seriesCapX) => {
      const { zToScreen } = useSmithChart();

      return useMemo(() => {
        // Tap ratio path
        const tapPath = [];
        for (let i = 0; i <= PATH_STEPS; i++) {
          const ratio = 1 + (tapRatio - 1) * (i / PATH_STEPS);
          const z = applyTapRatio(antR, antX, ratio);
          if (z.r > 0 && z.r < PATH_R_MAX) {
            tapPath.push(zToScreen(z.r, z.x));
          }
        }
        const afterTap = applyTapRatio(antR, antX, tapRatio);

        // Shunt inductance path - start exactly at afterTap point
        const shuntPath = [zToScreen(afterTap.r, afterTap.x)];
        for (let i = 1; i <= PATH_STEPS; i++) {
          const xL = SHUNT_X_START + (gammaRodX - SHUNT_X_START) * (i / PATH_STEPS);
          const z = addShuntReactance(afterTap.r, afterTap.x, xL);
          if (z.r > 0 && z.r < PATH_R_MAX && Math.abs(z.x) < PATH_X_MAX) {
            shuntPath.push(zToScreen(z.r, z.x));
          }
        }
        const afterShunt = addShuntReactance(afterTap.r, afterTap.x, gammaRodX);

        // Series capacitor path
        const seriesPath = [];
        for (let i = 0; i <= PATH_STEPS; i++) {
          const xC = -seriesCapX * (i / PATH_STEPS);
          const z = addSeriesReactance(afterShunt.r, afterShunt.x, xC);
          seriesPath.push(zToScreen(z.r, z.x));
        }
        const finalZ = addSeriesReactance(afterShunt.r, afterShunt.x, -seriesCapX);

        return {
          origPt: zToScreen(antR, antX),
          afterTapPt: zToScreen(afterTap.r, afterTap.x),
          afterShuntPt: zToScreen(afterShunt.r, afterShunt.x),
          finalPt: zToScreen(finalZ.r, finalZ.x),
          afterTap,
          afterShunt,
          finalZ,
          tapPath,
          shuntPath,
          seriesPath,
          swr: calcSWR(finalZ.r, finalZ.x)
        };
      }, [antR, antX, tapRatio, gammaRodX, seriesCapX, zToScreen]);
    };

    /**
     * Hook for hairpin/beta match calculations
     * @param {number} antR - Antenna resistance
     * @param {number} antX - Antenna reactance
     * @param {number} shortening - Shortening reactance
     * @param {number} hairpinX - Hairpin reactance
     * @returns {HairpinMatchResult}
     */
    const useHairpinMatch = (antR, antX, shortening, hairpinX) => {
      const { zToScreen } = useSmithChart();

      return useMemo(() => {
        // Shortening path
        const shortenPath = [];
        for (let i = 0; i <= PATH_STEPS; i++) {
          const xVal = antX - shortening * (i / PATH_STEPS);
          shortenPath.push(zToScreen(antR, xVal));
        }
        const afterShorten = { r: antR, x: antX - shortening };

        // Hairpin inductance path - start exactly at shortened point
        const hpPath = [zToScreen(afterShorten.r, afterShorten.x)];
        for (let i = 1; i <= PATH_STEPS; i++) {
          const xL = SHUNT_X_START + (hairpinX - SHUNT_X_START) * (i / PATH_STEPS);
          const z = addShuntReactance(afterShorten.r, afterShorten.x, xL);
          if (z.r > 0 && z.r < PATH_R_MAX && Math.abs(z.x) < PATH_X_MAX) {
            hpPath.push(zToScreen(z.r, z.x));
          }
        }
        const finalZ = addShuntReactance(afterShorten.r, afterShorten.x, hairpinX);

        return {
          origPt: zToScreen(antR, antX),
          shortenedPt: zToScreen(afterShorten.r, afterShorten.x),
          finalPt: zToScreen(finalZ.r, finalZ.x),
          afterShorten,
          finalZ,
          shortenPath,
          hpPath,
          swr: calcSWR(finalZ.r, finalZ.x)
        };
      }, [antR, antX, shortening, hairpinX, zToScreen]);
    };

    /**
     * Hook for auto-tuning functionality using Nelder-Mead optimization
     * @param {number} antR - Antenna resistance
     * @param {number} antX - Antenna reactance
     * @returns {Object} Auto-tune functions
     */
    const useAutoTune = (antR, antX) => {
      const autoTuneGamma = useCallback(() => {
        const { tap: t, rod: r, cap: c } = TUNE_BOUNDS.gamma;
        const result = fmin.nelderMead(([tap, rod, cap]) => {
          // Penalty for out-of-bounds
          if (tap < t.min || tap > t.max || rod < r.min || rod > r.max || cap < c.min || cap > c.max) {
            return SWR_MAX;
          }
          const z1 = applyTapRatio(antR, antX, tap);
          const z2 = addShuntReactance(z1.r, z1.x, rod);
          const z3 = addSeriesReactance(z2.r, z2.x, -cap);
          return calcSWR(z3.r, z3.x);
        }, [(t.min + t.max) / 2, (r.min + r.max) / 2, (c.min + c.max) / 2]);

        return {
          tapRatio: Math.round(result.x[0] * 100) / 100,
          gammaRodX: Math.round(result.x[1]),
          seriesCapX: Math.round(result.x[2])
        };
      }, [antR, antX]);

      const autoTuneHairpin = useCallback(() => {
        const { shorten: s, hp: h } = TUNE_BOUNDS.hairpin;
        const result = fmin.nelderMead(([shorten, hp]) => {
          // Penalty for out-of-bounds
          if (shorten < s.min || shorten > s.max || hp < h.min || hp > h.max) {
            return SWR_MAX;
          }
          const z1 = { r: antR, x: antX - shorten };
          const z2 = addShuntReactance(z1.r, z1.x, hp);
          return calcSWR(z2.r, z2.x);
        }, [(s.min + s.max) / 2, (h.min + h.max) / 2]);

        return {
          shortening: Math.round(result.x[0]),
          hairpinX: Math.round(result.x[1])
        };
      }, [antR, antX]);

      return { autoTuneGamma, autoTuneHairpin };
    };

    // ============================================================
    // Sub-Components
    // ============================================================

    /**
     * Arrow head component for path endpoints
     * @param {Object} props
     * @param {number} props.x - X position
     * @param {number} props.y - Y position
     * @param {number} props.angle - Rotation angle in degrees
     * @param {string} props.color - Fill color
     */
    const ArrowHead = ({ x, y, angle, color }) => (
      <polygon
        points="-7,-4 0,0 -7,4"
        fill={color}
        transform={`translate(${x}, ${y}) rotate(${angle})`}
      />
    );

    /**
     * Calculate arrow angle from path
     * @param {ScreenPoint[]} path - Array of points
     * @param {ScreenPoint} endPt - End point
     * @param {number} [offset=5] - Offset from end for angle calculation
     * @returns {number} Angle in degrees
     */
    const getArrowAngle = (path, endPt, offset = 5) => {
      if (path.length <= offset) return 0;
      const prev = path[path.length - offset];
      return Math.atan2(endPt.y - prev.y, endPt.x - prev.x) * 180 / Math.PI;
    };

    /**
     * Control panel wrapper component
     * @param {Object} props
     * @param {string} props.color - Border and header color
     * @param {string} props.title - Panel header text
     * @param {string} [props.tooltip] - Tooltip text
     * @param {React.ReactNode} props.children - Panel content
     */
    const ControlPanel = ({ color, title, tooltip, children }) => (
      <div className="control-panel" style={{ borderColor: color }} data-tooltip={tooltip}>
        <div className="control-header" style={{ color }}>{title}</div>
        {children}
      </div>
    );

    /** Gamma match physical arrangement diagram */
    const GammaDiagram = () => (
      <svg viewBox="0 0 450 130" className="diagram-svg">
        {/* Driven element */}
        <line x1="50" y1="50" x2="400" y2="50" stroke={COLORS.element} strokeWidth="6" strokeLinecap="round" />
        <circle cx="225" cy="50" r="3" fill="#333" />
        <text x="225" y="35" fill={COLORS.element} fontSize="10" textAnchor="middle">Driven Element ≈ λ/2</text>
        {/* Gamma rod */}
        <line x1="225" y1="65" x2="310" y2="65" stroke={COLORS.step2} strokeWidth="4" strokeLinecap="round" />
        <text x="268" y="80" fill={COLORS.step2} fontSize="9" textAnchor="middle">Gamma Rod (+jX)</text>
        {/* Tap point connection */}
        <line x1="310" y1="50" x2="310" y2="65" stroke={COLORS.step1} strokeWidth="2" />
        <circle cx="310" cy="50" r="4" fill={COLORS.step1} />
        <text x="310" y="100" fill={COLORS.step1} fontSize="8" textAnchor="middle">tap point</text>
        {/* Series capacitor */}
        <line x1="225" y1="65" x2="183" y2="65" stroke={COLORS.wire} strokeWidth="2" />
        <line x1="183" y1="59" x2="183" y2="71" stroke={COLORS.step3} strokeWidth="2" />
        <line x1="177" y1="59" x2="177" y2="71" stroke={COLORS.step3} strokeWidth="2" />
        <line x1="177" y1="65" x2="150" y2="65" stroke={COLORS.wire} strokeWidth="2" />
        <text x="180" y="84" fill={COLORS.step3} fontSize="9" textAnchor="middle">C</text>
        {/* Feed lines to coax */}
        <line x1="225" y1="50" x2="225" y2="56" stroke={COLORS.wire} strokeWidth="2" />
        <line x1="225" y1="56" x2="150" y2="56" stroke={COLORS.wire} strokeWidth="2" />
        <line x1="150" y1="56" x2="150" y2="65" stroke={COLORS.coax} strokeWidth="3" />
        <line x1="150" y1="60" x2="100" y2="60" stroke={COLORS.coax} strokeWidth="3" />
        <text x="75" y="64" fill={COLORS.coax} fontSize="9" textAnchor="middle">50Ω</text>
      </svg>
    );

    /** Hairpin/beta match physical arrangement diagram */
    const HairpinDiagram = () => (
      <svg viewBox="0 0 450 130" className="diagram-svg">
        {/* Driven element - split with gap */}
        <line x1="50" y1="50" x2="212" y2="50" stroke={COLORS.element} strokeWidth="6" strokeLinecap="round" />
        <line x1="238" y1="50" x2="400" y2="50" stroke={COLORS.element} strokeWidth="6" strokeLinecap="round" />
        <text x="131" y="35" fill={COLORS.element} fontSize="10" textAnchor="middle">&lt; λ/4</text>
        <text x="319" y="35" fill={COLORS.element} fontSize="10" textAnchor="middle">&lt; λ/4</text>
        <path d="M 215 56 L 215 90 Q 215 100 225 100 Q 235 100 235 90 L 235 56"
          fill="none" stroke={COLORS.hairpin} strokeWidth="4" strokeLinecap="round" />
        <text x="225" y="118" fill={COLORS.hairpin} fontSize="9" textAnchor="middle">Hairpin (+jX)</text>
        <line x1="215" y1="56" x2="150" y2="56" stroke={COLORS.wire} strokeWidth="2" />
        <line x1="235" y1="56" x2="235" y2="70" stroke={COLORS.wire} strokeWidth="2" />
        <line x1="235" y1="70" x2="150" y2="70" stroke={COLORS.wire} strokeWidth="2" />
        <line x1="150" y1="56" x2="150" y2="70" stroke={COLORS.coax} strokeWidth="3" />
        <line x1="150" y1="63" x2="100" y2="63" stroke={COLORS.coax} strokeWidth="3" />
        <text x="75" y="67" fill={COLORS.coax} fontSize="9" textAnchor="middle">50Ω</text>
      </svg>
    );

    // ============================================================
    // URL Parameter Utilities
    // ============================================================

    /**
     * Parse float from URL param with default
     * @param {string|null} val - URL parameter value
     * @param {number} def - Default value
     * @returns {number}
     */
    const parseParam = (val, def) => {
      if (val === null) return def;
      const n = parseFloat(val);
      return isNaN(n) ? def : n;
    };

    /** @type {Object} Default parameter values */
    const DEFAULTS = Object.freeze({
      mode: MODES.GAMMA,
      antR: 73,
      antX: 43,
      tapRatio: 1.0,
      gammaRodX: 300,
      seriesCapX: 30,
      shortening: 15,
      hairpinX: 50,
      freqMHz: '',
      elementDiamMm: '2'
    });

    /**
     * Check if all values match defaults
     * @param {Object} values - Current state values
     * @returns {boolean}
     */
    const isAtDefaults = (values) =>
      Object.keys(DEFAULTS).every(key => values[key] === DEFAULTS[key]);

    /**
     * Read initial state from URL parameters
     * @returns {Object} Initial state values from URL
     */
    const getUrlParams = () => {
      const params = new URLSearchParams(window.location.search);
      const modeParam = params.get(URL_KEYS.mode);
      return {
        mode: Object.values(MODES).includes(modeParam) ? modeParam : DEFAULTS.mode,
        antR: parseParam(params.get(URL_KEYS.antR), DEFAULTS.antR),
        antX: parseParam(params.get(URL_KEYS.antX), DEFAULTS.antX),
        tapRatio: parseParam(params.get(URL_KEYS.tapRatio), DEFAULTS.tapRatio),
        gammaRodX: parseParam(params.get(URL_KEYS.gammaRodX), DEFAULTS.gammaRodX),
        seriesCapX: parseParam(params.get(URL_KEYS.seriesCapX), DEFAULTS.seriesCapX),
        shortening: parseParam(params.get(URL_KEYS.shortening), DEFAULTS.shortening),
        hairpinX: parseParam(params.get(URL_KEYS.hairpinX), DEFAULTS.hairpinX),
        freqMHz: params.get(URL_KEYS.freqMHz) || DEFAULTS.freqMHz,
        elementDiamMm: params.get(URL_KEYS.elementDiamMm) || DEFAULTS.elementDiamMm
      };
    };

    const initialParams = getUrlParams();

    /**
     * Get CSS class for SWR value
     * @param {number} swr - Standing wave ratio
     * @returns {string} CSS class name
     */
    const getSWRClass = (swr) => {
      if (swr < SWR_THRESHOLDS.excellent) return 'swr-excellent';
      if (swr < SWR_THRESHOLDS.good) return 'swr-good';
      if (swr < SWR_THRESHOLDS.ok) return 'swr-ok';
      return 'swr-poor';
    };

    // ============================================================
    // Main Component
    // ============================================================

    function AntennaMatching() {
      const [p, setP] = useState(initialParams);
      const set = (updates) => setP(prev => ({ ...prev, ...updates }));

      /** Helper for numeric input onChange handlers */
      const setNum = (key) => (e) => set({ [key]: Number(e.target.value) });

      /** Helper for string input onChange handlers */
      const setStr = (key) => (e) => set({ [key]: e.target.value });

      // Destructure for convenience
      const { mode, antR, antX, tapRatio, gammaRodX, seriesCapX, shortening, hairpinX, freqMHz, elementDiamMm } = p;
      const isGamma = mode === MODES.GAMMA;

      // Update URL when state changes
      useEffect(() => {
        if (isAtDefaults(p)) {
          window.history.replaceState(null, '', window.location.pathname);
          return;
        }

        const params = new URLSearchParams();
        params.set(URL_KEYS.mode, p.mode);
        params.set(URL_KEYS.antR, Math.round(p.antR));
        params.set(URL_KEYS.antX, Math.round(p.antX));
        if (isGamma) {
          params.set(URL_KEYS.tapRatio, p.tapRatio.toFixed(2));
          params.set(URL_KEYS.gammaRodX, Math.round(p.gammaRodX));
          params.set(URL_KEYS.seriesCapX, Math.round(p.seriesCapX));
        } else {
          params.set(URL_KEYS.shortening, Math.round(p.shortening));
          params.set(URL_KEYS.hairpinX, Math.round(p.hairpinX));
        }
        if (p.freqMHz) params.set(URL_KEYS.freqMHz, p.freqMHz);
        if (p.elementDiamMm && p.elementDiamMm !== DEFAULTS.elementDiamMm) params.set(URL_KEYS.elementDiamMm, p.elementDiamMm);

        const newUrl = `${window.location.pathname}?${params.toString()}`;
        window.history.replaceState(null, '', newUrl);
      }, [p]);

      // Hooks
      const { rCircles, xArcs, createXArc } = useSmithChart();
      const gammaPaths = useGammaMatch(antR, antX, tapRatio, gammaRodX, seriesCapX);
      const hairpinPaths = useHairpinMatch(antR, antX, shortening, hairpinX);
      const { autoTuneGamma, autoTuneHairpin } = useAutoTune(antR, antX);

      // Physical calculations (when freq/diameter are provided)
      const physical = useMemo(() => {
        const freq = parseFloat(freqMHz);
        const diam = parseFloat(elementDiamMm);
        if (!freq || freq <= 0) return null;

        const lambda = C_SPEED / (freq * 1e6); // wavelength in meters
        const lambdaMm = lambda * 1000;

        // Capacitor value: C = 1/(2πfXc)
        const capPf = seriesCapX > 0 ? 1e12 / (2 * Math.PI * freq * 1e6 * seriesCapX) : null;

        // Tap point distance from center: d = (λ/2π) * arccos(1/n)
        const tapDistMm = (lambdaMm / (2 * Math.PI)) * Math.acos(1 / tapRatio);

        // Element shortening (requires diameter)
        let shortenMm = null;
        let shortenPct = null;
        if (diam && diam > 0) {
          // Characteristic impedance: Z0 ≈ 276 * log10(λ/(2*d))
          const z0Ant = 276 * Math.log10(lambdaMm / (2 * diam));
          // ΔX ≈ -Z0 * π * Δ(L/λ), so Δ(L/λ) ≈ -ΔX / (Z0 * π)
          const deltaLOverLambda = shortening / (z0Ant * Math.PI);
          shortenMm = deltaLOverLambda * lambdaMm / 2; // per side (quarter wave each side)
          shortenPct = (deltaLOverLambda / 0.5) * 100; // as % of λ/2
        }

        return { lambda, lambdaMm, capPf, tapDistMm, shortenMm, shortenPct };
      }, [freqMHz, elementDiamMm, seriesCapX, shortening, tapRatio]);

      const paths = isGamma ? gammaPaths : hairpinPaths;
      const swr = paths.swr;

      const handleAutoTune = () => {
        if (isGamma) {
          set(autoTuneGamma());
        } else {
          set(autoTuneHairpin());
        }
      };

      const handlePreset = (preset) => {
        set({ antR: preset.r, antX: preset.x });
      };

      const isPresetActive = (preset) => antR === preset.r && antX === preset.x;

      return (
        <div className="app">
          {/* Mode Toggle */}
          <div className="mode-toggle">
            <button
              className={`btn mode-btn ${isGamma ? 'active-gamma' : ''}`}
              onClick={() => set({ mode: MODES.GAMMA })}
            >
              Gamma Match
            </button>
            <button
              className={`btn mode-btn ${mode === MODES.HAIRPIN ? 'active-hairpin' : ''}`}
              onClick={() => set({ mode: MODES.HAIRPIN })}
            >
              Beta (Hairpin) Match
            </button>
          </div>

          <h1 className="title">
            {isGamma ? 'Gamma Match' : 'Beta (Hairpin) Match'}
          </h1>
          <div className="footer" style={{ marginTop: '-12px' }}>By AI6KG &lt;<a href="mailto:ai6kg@arrl.net">ai6kg@arrl.net</a>&gt;</div>

          {/* Presets */}
          <div className="presets">
            {PRESETS.map((preset) => (
              <button
                key={preset.label}
                className={`btn preset-btn ${isPresetActive(preset) ? 'active' : ''}`}
                onClick={() => handlePreset(preset)}
              >
                {preset.label}
              </button>
            ))}
            <button
              className={`btn auto-tune-btn ${mode}`}
              onClick={handleAutoTune}
              data-tooltip="Find optimal match parameters"
            >
              Auto-Tune
            </button>
          </div>

          {/* Physical Parameters (optional) */}
          <div className="physical-params">
            <label>
              Freq (MHz):
              <input
                type="number"
                value={freqMHz}
                onChange={setStr('freqMHz')}
                min="1"
                max="3000"
                step="0.1"
              />
            </label>
            {!isGamma && (
              <label>
                Element ⌀ (mm):
                <input
                  type="number"
                  value={elementDiamMm}
                  onChange={setStr('elementDiamMm')}
                  min="0.1"
                  max="100"
                  step="0.1"
                />
              </label>
            )}
            <span style={{ color: '#555', alignSelf: 'center', minWidth: '90px' }}>
              {physical ? `λ = ${(physical.lambdaMm / 1000).toFixed(2)}m` : ''}
            </span>
            <button
              className="btn preset-btn"
              onClick={() => navigator.clipboard.writeText(window.location.href)}
              style={{ alignSelf: 'center' }}
              data-tooltip="Copy shareable link to clipboard"
            >
              Copy URL
            </button>
            <button
              className="btn preset-btn"
              onClick={() => window.location.href = window.location.pathname}
              style={{ alignSelf: 'center' }}
              data-tooltip="Reset all parameters to defaults"
            >
              Reset
            </button>
          </div>

          <div className="main-content">
            {/* Smith Chart */}
            <svg width={SIZE} height={SIZE} viewBox={`0 0 ${SIZE} ${SIZE}`} className="smith-chart">
              {/* Outer circle */}
              <circle cx={CX} cy={CY} r={RADIUS} fill="none" stroke={COLORS.gridOuter} strokeWidth="2" />

              {/* Resistance circles */}
              {rCircles.map(({ r, cx, radius }) => (
                <circle key={`r-${r}`} cx={cx} cy={CY} r={radius} fill="none" stroke={COLORS.grid} strokeWidth="1" />
              ))}

              {/* Reactance arcs */}
              {xArcs.map(({ x, cx, cy, radius }) => {
                const pts = createXArc(x, cx, cy, radius);
                if (pts.length < 2) return null;
                return <path key={`x-${x}`} d={pointsToPath(pts)} fill="none" stroke={COLORS.grid} strokeWidth="1" />;
              })}

              {/* Center line */}
              <line x1={CX - RADIUS} y1={CY} x2={CX + RADIUS} y2={CY} stroke={COLORS.gridCenter} strokeWidth="1" />

              {/* Labels */}
              <text x={CX - RADIUS - 8} y={CY + 4} fill={COLORS.label} fontSize="10" textAnchor="end">0</text>
              <text x={CX + RADIUS + 8} y={CY + 4} fill={COLORS.label} fontSize="10" textAnchor="start">∞</text>
              <text x={CX} y={CY - 8} fill={COLORS.label} fontSize="9" textAnchor="middle">50Ω</text>
              <text x={CX} y={CY - RADIUS - 8} fill={COLORS.label} fontSize="9" textAnchor="middle">+jX</text>
              <text x={CX} y={CY + RADIUS + 16} fill={COLORS.label} fontSize="9" textAnchor="middle">−jX</text>

              {isGamma ? (
                <>
                  {/* Tap ratio path */}
                  {gammaPaths.tapPath.length > 1 && (
                    <path
                      d={pointsToPath(gammaPaths.tapPath)}
                      fill="none" stroke={COLORS.step1} strokeWidth="3" strokeDasharray="6,4" strokeLinecap="round"
                    />
                  )}
                  {/* Shunt inductance path */}
                  {gammaPaths.shuntPath.length > 1 && (
                    <path
                      d={pointsToPath(gammaPaths.shuntPath)}
                      fill="none" stroke={COLORS.step2} strokeWidth="3" strokeLinecap="round"
                    />
                  )}
                  {/* Series capacitor path */}
                  {gammaPaths.seriesPath.length > 1 && (
                    <path
                      d={pointsToPath(gammaPaths.seriesPath)}
                      fill="none" stroke={COLORS.step3} strokeWidth="3" strokeLinecap="round"
                    />
                  )}
                  {/* Arrows */}
                  {gammaPaths.tapPath.length > 3 && (
                    <ArrowHead x={gammaPaths.afterTapPt.x} y={gammaPaths.afterTapPt.y}
                      angle={getArrowAngle(gammaPaths.tapPath, gammaPaths.afterTapPt)} color={COLORS.step1} />
                  )}
                  {gammaPaths.shuntPath.length > 3 && (
                    <ArrowHead x={gammaPaths.afterShuntPt.x} y={gammaPaths.afterShuntPt.y}
                      angle={getArrowAngle(gammaPaths.shuntPath, gammaPaths.afterShuntPt)} color={COLORS.step2} />
                  )}
                  {gammaPaths.seriesPath.length > 3 && (
                    <ArrowHead x={gammaPaths.finalPt.x} y={gammaPaths.finalPt.y}
                      angle={getArrowAngle(gammaPaths.seriesPath, gammaPaths.finalPt)} color={COLORS.step3} />
                  )}
                  {/* Points */}
                  <circle cx={gammaPaths.origPt.x} cy={gammaPaths.origPt.y} r="10" fill={COLORS.orig} stroke="#fff" strokeWidth="2" />
                  <text x={gammaPaths.origPt.x - 14} y={gammaPaths.origPt.y - 14}
                    fill={COLORS.orig} fontSize="11" fontWeight="600" textAnchor="end">
                    ① {antR}{antX >= 0 ? '+' : ''}j{antX}Ω
                  </text>
                  <circle cx={gammaPaths.afterTapPt.x} cy={gammaPaths.afterTapPt.y} r="7" fill={COLORS.step1} stroke="#fff" strokeWidth="2" />
                  <circle cx={gammaPaths.afterShuntPt.x} cy={gammaPaths.afterShuntPt.y} r="7" fill={COLORS.step2} stroke="#fff" strokeWidth="2" />
                  <circle cx={gammaPaths.finalPt.x} cy={gammaPaths.finalPt.y} r="10" fill={COLORS.final} stroke="#fff" strokeWidth="2" />
                  <text x={gammaPaths.finalPt.x + 14} y={gammaPaths.finalPt.y + 4} fill={COLORS.final} fontSize="11" fontWeight="600">
                    ④ {gammaPaths.finalZ.r.toFixed(0)}Ω
                  </text>
                </>
              ) : (
                <>
                  {/* Shortening path */}
                  {hairpinPaths.shortenPath.length > 1 && (
                    <path
                      d={pointsToPath(hairpinPaths.shortenPath)}
                      fill="none" stroke={COLORS.step1} strokeWidth="3" strokeDasharray="6,4" strokeLinecap="round"
                    />
                  )}
                  {/* Hairpin path */}
                  {hairpinPaths.hpPath.length > 1 && (
                    <path
                      d={pointsToPath(hairpinPaths.hpPath)}
                      fill="none" stroke={COLORS.hairpin} strokeWidth="3" strokeLinecap="round"
                    />
                  )}
                  {/* Arrows */}
                  {hairpinPaths.shortenPath.length > 3 && (
                    <ArrowHead x={hairpinPaths.shortenedPt.x} y={hairpinPaths.shortenedPt.y}
                      angle={getArrowAngle(hairpinPaths.shortenPath, hairpinPaths.shortenedPt)} color={COLORS.step1} />
                  )}
                  {hairpinPaths.hpPath.length > 3 && (
                    <ArrowHead x={hairpinPaths.finalPt.x} y={hairpinPaths.finalPt.y}
                      angle={getArrowAngle(hairpinPaths.hpPath, hairpinPaths.finalPt)} color={COLORS.hairpin} />
                  )}
                  {/* Points */}
                  <circle cx={hairpinPaths.origPt.x} cy={hairpinPaths.origPt.y} r="10" fill={COLORS.orig} stroke="#fff" strokeWidth="2" />
                  <text x={hairpinPaths.origPt.x + 14} y={hairpinPaths.origPt.y + 4}
                    fill={COLORS.orig} fontSize="11" fontWeight="600">
                    ① {antR}{antX >= 0 ? '+' : ''}j{antX}Ω
                  </text>
                  <circle cx={hairpinPaths.shortenedPt.x} cy={hairpinPaths.shortenedPt.y} r="7" fill={COLORS.step1} stroke="#fff" strokeWidth="2" />
                  <text x={hairpinPaths.shortenedPt.x + 12} y={hairpinPaths.shortenedPt.y - 8}
                    fill={COLORS.step1} fontSize="10">② Shortened</text>
                  <circle cx={hairpinPaths.finalPt.x} cy={hairpinPaths.finalPt.y} r="10" fill={COLORS.final} stroke="#fff" strokeWidth="2" />
                  <text x={hairpinPaths.finalPt.x + 14} y={hairpinPaths.finalPt.y + 4} fill={COLORS.final} fontSize="11" fontWeight="600">
                    ③ {hairpinPaths.finalZ.r.toFixed(0)}Ω
                  </text>
                </>
              )}

              {/* 50Ω target */}
              <circle cx={CX} cy={CY} r="6" fill="none" stroke={COLORS.hairpin} strokeWidth="2" strokeDasharray="3,3" />

              {/* Legend */}
              <g transform={`translate(${CX - RADIUS + 10}, ${CY + RADIUS - 80})`}>
                {isGamma ? (
                  <>
                    <line x1="0" y1="0" x2="20" y2="0" stroke={COLORS.step1} strokeWidth="3" strokeDasharray="6,4" />
                    <text x="26" y="4" fill={COLORS.step1} fontSize="9">② Autotransformer</text>
                    <line x1="0" y1="16" x2="20" y2="16" stroke={COLORS.step2} strokeWidth="3" />
                    <text x="26" y="20" fill={COLORS.step2} fontSize="9">③ Shunt L</text>
                    <line x1="0" y1="32" x2="20" y2="32" stroke={COLORS.step3} strokeWidth="3" />
                    <text x="26" y="36" fill={COLORS.step3} fontSize="9">④ Series C</text>
                  </>
                ) : (
                  <>
                    <line x1="0" y1="0" x2="20" y2="0" stroke={COLORS.step1} strokeWidth="3" strokeDasharray="6,4" />
                    <text x="26" y="4" fill={COLORS.step1} fontSize="9">② Shorten</text>
                    <line x1="0" y1="16" x2="20" y2="16" stroke={COLORS.hairpin} strokeWidth="3" />
                    <text x="26" y="20" fill={COLORS.hairpin} fontSize="9">③ Hairpin</text>
                  </>
                )}
              </g>
            </svg>

            {/* Controls */}
            <div className="controls">
              {/* Antenna Impedance */}
              <ControlPanel color={COLORS.orig} title="① ANTENNA IMPEDANCE" tooltip="Starting impedance of the antenna feedpoint">
                <label className="control-label">
                  <span className="control-text">Resistance: {antR}Ω</span>
                  <input type="range" min="10" max="150" value={antR}
                    onChange={setNum('antR')}
                    aria-label="Antenna resistance"
                    className="control-slider" style={{ accentColor: COLORS.orig }} />
                </label>
                <label className="control-label">
                  <span className="control-text">
                    Reactance: {antX >= 0 ? '+' : ''}j{antX}Ω {antX > 0 ? '(L)' : antX < 0 ? '(C)' : ''}
                  </span>
                  <input type="range" min="-100" max="100" value={antX}
                    onChange={setNum('antX')}
                    aria-label="Antenna reactance"
                    className="control-slider" style={{ accentColor: COLORS.orig }} />
                </label>
                <div className="impedance-display">
                  Z = {antR} {antX >= 0 ? '+' : '−'} j{Math.abs(antX)} Ω
                </div>
              </ControlPanel>

              {isGamma ? (
                <>
                  {/* Tap Ratio */}
                  <ControlPanel color={COLORS.step1} title="② AUTOTRANSFORMER (TAP RATIO)" tooltip="Impedance step-up via tap position on driven element">
                    <label className="control-label">
                      <span className="control-text">n = {tapRatio.toFixed(2)} (Z × {(tapRatio * tapRatio).toFixed(2)})</span>
                      <input type="range" min="1" max="2.5" step="0.01" value={tapRatio}
                        onChange={setNum('tapRatio')}
                        aria-label="Tap ratio"
                        className="control-slider" style={{ accentColor: COLORS.step1 }} />
                    </label>
                    <div className="control-result">→ {formatZ(gammaPaths.afterTap.r, gammaPaths.afterTap.x)} Ω</div>
                    {physical && (
                      <div className="physical-hint">≈ {Math.round(physical.tapDistMm)} mm from center</div>
                    )}
                  </ControlPanel>

                  {/* Gamma Rod */}
                  <ControlPanel color={COLORS.step2} title="③ GAMMA ROD (SHUNT +jX)" tooltip="Parallel inductance from gamma rod coupling">
                    <label className="control-label">
                      <span className="control-text">Rod reactance: +j{gammaRodX}Ω</span>
                      <input type="range" min="20" max="400" value={gammaRodX}
                        onChange={setNum('gammaRodX')}
                        aria-label="Gamma rod reactance"
                        className="control-slider" style={{ accentColor: COLORS.step2 }} />
                    </label>
                    <div className="control-result">→ {formatZ(gammaPaths.afterShunt.r, gammaPaths.afterShunt.x)} Ω</div>
                  </ControlPanel>

                  {/* Series Capacitor */}
                  <ControlPanel color={COLORS.step3} title="④ SERIES CAPACITOR" tooltip="Cancels inductive reactance to reach 50Ω">
                    <label className="control-label">
                      <span className="control-text">Cap reactance: −j{seriesCapX}Ω</span>
                      <input type="range" min="0" max="100" value={seriesCapX}
                        onChange={setNum('seriesCapX')}
                        aria-label="Series capacitor reactance"
                        className="control-slider" style={{ accentColor: COLORS.step3 }} />
                    </label>
                    {physical && physical.capPf && (
                      <div className="physical-hint">≈ {Math.round(physical.capPf)} pF at {freqMHz} MHz</div>
                    )}
                  </ControlPanel>
                </>
              ) : (
                <>
                  {/* Shortening */}
                  <ControlPanel color={COLORS.step1} title="② SHORTEN ELEMENT" tooltip="Capacitive reactance from shortened driven element">
                    <label className="control-label">
                      <span className="control-text">Capacitive reactance: −j{shortening}Ω</span>
                      <input type="range" min="0" max="60" value={shortening}
                        onChange={setNum('shortening')}
                        aria-label="Element shortening reactance"
                        className="control-slider" style={{ accentColor: COLORS.step1 }} />
                    </label>
                    <div className="control-result">→ {formatZ(hairpinPaths.afterShorten.r, hairpinPaths.afterShorten.x)} Ω</div>
                    {physical && physical.shortenMm !== null ? (
                      <div className="physical-hint">
                        ≈ {physical.shortenMm.toFixed(1)} mm per side ({physical.shortenPct.toFixed(1)}% of λ/2)
                      </div>
                    ) : (
                      <div className="control-hint">Constant-R circle (series reactance)</div>
                    )}
                  </ControlPanel>

                  {/* Hairpin */}
                  <ControlPanel color={COLORS.hairpin} title="③ HAIRPIN (PARALLEL +jX)" tooltip="Shunt inductor transforms impedance up to 50Ω">
                    <label className="control-label">
                      <span className="control-text">Inductive reactance: +j{hairpinX}Ω</span>
                      <input type="range" min="15" max="200" value={hairpinX}
                        onChange={setNum('hairpinX')}
                        aria-label="Hairpin reactance"
                        className="control-slider" style={{ accentColor: COLORS.hairpin }} />
                    </label>
                    <div className="control-hint">Constant-G circle (shunt susceptance)</div>
                  </ControlPanel>
                </>
              )}

              {/* Result */}
              <div className={`result-panel ${swr < 1.5 ? 'good' : 'normal'}`}
                style={{ borderColor: swr < 1.5 ? COLORS.hairpin : COLORS.final }}
                aria-live="polite">
                <div className="control-header" style={{ color: COLORS.final }}>MATCHED IMPEDANCE</div>
                <div className="result-z">Z = {formatZ(paths.finalZ.r, paths.finalZ.x)} Ω</div>
                <div className={`result-swr ${getSWRClass(swr)}`}>
                  SWR = {swr.toFixed(3)} : 1
                </div>
              </div>
            </div>
          </div>

          {/* Physical diagram */}
          <div className="diagram-container">
            <div className="diagram-title">
              {isGamma ? 'GAMMA MATCH PHYSICAL ARRANGEMENT' : 'BETA (HAIRPIN) MATCH PHYSICAL ARRANGEMENT'}
            </div>
            {isGamma ? <GammaDiagram /> : <HairpinDiagram />}
          </div>

          {/* Info */}
          <div className="info">
            {isGamma ? (
              <>
                <strong>Gamma Match:</strong> Uses tap ratio to scale Z, shunt inductor (gamma rod), and series capacitor.
                Works for both high-Z and low-Z antennas by adjusting the tap position.
              </>
            ) : (
              <>
                <strong>Beta (Hairpin) Match:</strong> Shorten the driven element to add capacitive reactance,
                then use a parallel inductor (hairpin) to transform up to 50Ω. Best for low-Z antennas like Yagis.
              </>
            )}
          </div>

          {/* Footer */}
          <div className="footer">
            © 2025 Christopher Hoover. <a href="https://github.com/charlieh0tel/ham_radio/blob/master/LICENSE">MIT License</a>.{' '}
            <a href="https://github.com/charlieh0tel/ham_radio">GitHub</a>
          </div>
        </div>
      );
    }

    ReactDOM.createRoot(document.getElementById('root')).render(<AntennaMatching />);
  </script>
</body>
</html>
